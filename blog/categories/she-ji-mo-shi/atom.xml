<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 设计模式 | 逆风@{iOS}]]></title>
  <link href="http://ios.dehengxu.com/blog/categories/she-ji-mo-shi/atom.xml" rel="self"/>
  <link href="http://ios.dehengxu.com/"/>
  <updated>2015-08-19T17:18:22+08:00</updated>
  <id>http://ios.dehengxu.com/</id>
  <author>
    <name><![CDATA[Deheng Xu]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[设计模式-访问者模式]]></title>
    <link href="http://ios.dehengxu.com/blog/2015/08/16/design-pattern-visitor/"/>
    <updated>2015-08-16T08:05:25+08:00</updated>
    <id>http://ios.dehengxu.com/blog/2015/08/16/design-pattern-visitor</id>
    <content type="html"><![CDATA[<h3>模式说明：</h3>

<blockquote><p>访问者模式(Visitor Pattern)，是一种具有双分派能力的模式，它通过 Visitor 接口约定为已有类 Element 进行扩展，扩展的目标是尽可能少的修改已有类 Element ，在 Visitor 中增加新扩展的接口，对 Element 中的现有接口进行访问。而 Visitor 以外的部分，不需要知道 Element 的具体实现和操作，进行了封装。
所谓<code>双分派</code>指的是，该模式可以通过不同的 <code>Visitor</code> 对不同的 <code>Element</code> 进行访问。</p></blockquote>

<p>举例：</p>

<blockquote><p>场景介绍，以学校为背景，引入 Teacher, Student, Parent 三类人作为已有类型， 引入 ConcreteVisitor 作为 Visitor 的具体实现类，对以上三者进行扩展。</p>

<p><code>ElementProtocol</code> 作为 Teacher, Student, Parent 的公共接口协议。
<code>VisitorProtocol</code> 作为访问者的公共接口协议。
<code>Teacher, Student, Parent</code> 三者是具体的 Element 实现。
<code>ConcreteVisitor</code> 是具体的 Visitor 实现。</p></blockquote>

<p>当学校外面的人需要访问 <code>Teacher</code> 的时候，不需要直接与 <code>Teacher</code> 交流，而是去找 <code>ConcreteVisitor</code> 通过它与 <code>Teacher</code> 进行交流。</p>

<p><a href="https://github.com/xudeheng/ObjcDesignPatterns">Objective-c源码</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[常用23种设计模式简介]]></title>
    <link href="http://ios.dehengxu.com/blog/2015/08/15/chang-yong-23chong-she-ji-mo-shi-jian-jie/"/>
    <updated>2015-08-15T23:47:51+08:00</updated>
    <id>http://ios.dehengxu.com/blog/2015/08/15/chang-yong-23chong-she-ji-mo-shi-jian-jie</id>
    <content type="html"><![CDATA[<p>根据设计模式的作用分类，23种设计模式可以分为以下几类:</p>

<h3>对象创建</h3>

<p>单例模式，工厂模式，抽象工厂，原型模式，生成器模式</p>

<h3>接口适配</h3>

<p>适配器模式，桥接模式，外观模式</p>

<h3>对象解耦</h3>

<p>中介者模式，观察者模式</p>

<h3>抽象集合</h3>

<p>组合模式，迭代器模式</p>

<h3>行为</h3>

<p>访问者模式, 装饰器模式，责任链模式</p>

<h3>逻辑封装</h3>

<p>模板方法，策略模式，命令模式</p>

<h3>对象访问</h3>

<p>享元模式，代理模式</p>

<h3>对象状态</h3>

<p>备忘录模式</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设计模式-观察者模式]]></title>
    <link href="http://ios.dehengxu.com/blog/2015/08/15/design-pattern-observer/"/>
    <updated>2015-08-15T23:46:46+08:00</updated>
    <id>http://ios.dehengxu.com/blog/2015/08/15/design-pattern-observer</id>
    <content type="html"><![CDATA[
]]></content>
  </entry>
  
</feed>
