
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>逆风@[iOS,android,nil]</title>
  <meta name="author" content="Deheng Xu">

  
  <meta name="description" content="Use Dispatch Source Timer Aug 27th, 2015 4:58 pm | Comments Bash 使用技巧 Aug 23rd, 2015 11:11 pm | Comments GCD 的常规用法 Aug 23rd, 2015 3:56 pm | Comments &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://tech.dehengxu.com/posts/4/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="逆风@[iOS,android,nil]" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <!-- // <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script> -->
  <script src="/javascripts/libs/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>  
  <!--<script src="/javascript/search.min.js" type="text/javascript" charset="utf-8"></script> -->

  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
  <!-- Swiftype search enging. -->
  <script type="text/javascript">
  (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
  (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
  e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
  })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');

  _st('install','tGsyyVJ9i6xiZc8ukjUV','2.0.0');
</script>

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">逆风@[iOS,android,nil]</a></h1>
  
    <h2>A blog focus on iOS, Android, techs.</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/devres">开发资源</a></li>
  <li><a href="/works">Works</a></li>
</ul>

<form>
  <fieldset role="search">
    <input class="st-default-search-input" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title" ><a href="/blog/use-dispatch-source-timer/">Use Dispatch Source Timer</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-08-27T16:58:03+08:00'><span class='date'><span class='date-month'>Aug</span> <span class='date-day'>27</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>4:58 pm</span></time>
        
           | <a href="/blog/use-dispatch-source-timer/#disqus_thread"
             data-disqus-identifier="http://tech.dehengxu.com/blog/use-dispatch-source-timer/">Comments</a>
        
      </p>
    
  </header>



<!-- <div class="entry-content"><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>dispatch_queue_t queue = dispatch_queue_create("com.xxx.timer", DISPATCH_QUEUE_CONCURRENT);
</span><span class='line'>
</span><span class='line'>dispatch_source_t timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue);
</span><span class='line'>
</span><span class='line'>dispatch_source_set_timer(timer, DISPATCH_TIME_NOW, 1 * NSEC_PER_SEC, NSEC_PER_SEC / 10);
</span><span class='line'>
</span><span class='line'>// 设置定时器回调 block
</span><span class='line'>dispatch_source_set_event_handler(timer, ^ {
</span><span class='line'>  //do something...
</span><span class='line'>});
</span><span class='line'>
</span><span class='line'>dispatch_resume(timer);
</span></code></pre></td></tr></table></div></figure>


<p>关键点： timer 一定要被 retain ，防止提前释放，否则 timer 无效。</p>

<p>关闭 timer 可以使用 <code>dispatch_source_cancel</code> 函数。</p>
</div> -->

  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title" ><a href="/blog/bash-shi-yong-ji-qiao/">Bash 使用技巧</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-08-23T23:11:02+08:00'><span class='date'><span class='date-month'>Aug</span> <span class='date-day'>23</span><span class='date-suffix'>rd</span>, <span class='date-year'>2015</span></span> <span class='time'>11:11 pm</span></time>
        
           | <a href="/blog/bash-shi-yong-ji-qiao/#disqus_thread"
             data-disqus-identifier="http://tech.dehengxu.com/blog/bash-shi-yong-ji-qiao/">Comments</a>
        
      </p>
    
  </header>



<!-- <div class="entry-content"><h4>递归搜索目录下所有文件内容</h4>

<p>bash</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>ls ./**/*.ext | xargs grep algorit</span></code></pre></td></tr></table></div></figure>


<blockquote><p>搜索当前目录下所有的 ext 文件，并且匹配是否包含关键词 <code>algorit</code></p></blockquote>

<h4>查找进程</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>es -ef|grep name</span></code></pre></td></tr></table></div></figure>


<blockquote><p>查找进程名包含 <code>name</code> 的进程</p></blockquote>

<h4>查看开启的端口</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>lsof -i:8080</span></code></pre></td></tr></table></div></figure>


<blockquote><p>查看使用端口 8080 的进程</p></blockquote>
</div> -->

  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title" ><a href="/blog/gcd-de-chang-gui-yong-fa/">GCD 的常规用法</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-08-23T15:56:50+08:00'><span class='date'><span class='date-month'>Aug</span> <span class='date-day'>23</span><span class='date-suffix'>rd</span>, <span class='date-year'>2015</span></span> <span class='time'>3:56 pm</span></time>
        
           | <a href="/blog/gcd-de-chang-gui-yong-fa/#disqus_thread"
             data-disqus-identifier="http://tech.dehengxu.com/blog/gcd-de-chang-gui-yong-fa/">Comments</a>
        
      </p>
    
  </header>



<!-- <div class="entry-content"><p>GCD 通过将多线程抽象为 <code>dispatch_queue_t</code> 类型的对象，以 Block 作为计算单元实现的一套基于 C 语言的开源多线程库 <code>libdispatch</code>。</p>

<p>GCD 让多线程开发变的更加方便，简洁。</p>

<p>首先明确几个 GCD 中的特性:</p>

<ol>
<li>全局队列都是异步的。</li>
<li>主队列是同步的。</li>
<li>串行队列中在当前上下文执行同步计算会产生死锁。</li>
</ol>


<h3>创建并行，串行队列</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>dispatch_queue_create("q1", DISPATCH_QUEUE_CONCURRENT);</span></code></pre></td></tr></table></div></figure>




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>dispatch_queue_create("q1", DISPATCH_QUEUE_SERIAL);</span></code></pre></td></tr></table></div></figure>


<h3>异步执行任务</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>disaptch_async(queue, ^() {
</span><span class='line'>  //Todo....
</span><span class='line'>});</span></code></pre></td></tr></table></div></figure>


<h3>同步执行任务的方式</h3>

<ol>
<li><p>dispatch_semaphor_t</p>

<pre><code>dispatch_semaphor_t semaphor = disaptch_semaphor_create(1);

dispatch_async(queue, ^() {
    dispatch_semaphor_wait(semaphor);
    //Todo...

    //Finished.
    dispatch_semaphor_signal(semaphor);
});
</code></pre>

<p>创建一个只允许一个线程访问的信号量 <code>disaptch_semaphor_create(1);</code></p>

<p>通知其他访问对象等待 <code>dispatch_semaphor_wait(semaphor);</code></p>

<p>资源访问结束后，退回占用的资源，并通知其他访问对象可以进行访问。 <code>dispatch_semaphor_signal(semaphor);</code></p></li>
<li><p>dispatch_group_wait</p>

<pre><code>dispatch_group_t group = dispatch_group_create();

dispatch_group_async(group, q1, ^ {
    //Task 1.
});

dispatch_group_async(group, q1, ^ {
    //Task 2.
});

dispatch_group_async(group, q1, ^ {
    //Task 3.
});

dispatch_async(queue, ^() {
    dispatch_group_wait(group);
    //Todo....

});
</code></pre>

<p><code>dispatch_group_async</code>: 添加任务到分组中。</p>

<p><code>dispatch_group_wait(group);</code> 等待 group 里的所有任务完成后方可继续。</p></li>
<li><p>dispatch_group_notify</p>

<pre><code>dispatch_group_notify(group, q1, ^ {
    //Todo...

});
</code></pre>

<p><code>dispatch_group_notify</code>: group中的所有任务完成后，执行 block 中的代码。</p></li>
<li><p>dispatch_group_enter, dispatch_group_leave</p>

<pre><code>dispatch_group_enter(group);

dispatch_async(q1, ^ {
    //Todo...

    dispatch_group_leave(group);
});
</code></pre>

<p>该代码等价于:</p>

<pre><code>dispatch_group_async(q1, ^ {
    //Todo...
});
</code></pre>

<p>作用也是将任务放入到 q1 队列中，同时也添加到分组中。</p></li>
</ol>


<h3>使用 apply 来提高并行效率</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>dispatch_apply(5000, q1, ^(size_t i) {
</span><span class='line'>    NSLog(@"%zu",  i);
</span><span class='line'>});</span></code></pre></td></tr></table></div></figure>


<p>你会发现如果 q1 是并发队列，输出的数字是无序的状态。这就是 dispatch_apply 带来的好处，它能快速将当前的迭代任务立刻发送到队列中执行，如果是并发队列，这个效率是很高的。如果你对任务的顺序有要求，或者队列是串行队列，那就不需要使用 dispatch_apply 了。</p>

<h3>dispatch_barrier_async</h3>

<p>阻碍异步，意思是通过 dispatch_barrier_async 提交的任务，不会立刻执行，而是会阻碍它之后提交的任务，直到它之前的任务全部完成，它才会执行，并且它执行完毕后，其后提交的任务才能继续进行。</p>

<p>而在 dispatch_barrier_async 之前或者之后的任务都是并发执行的。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>dispatch_queue_t q = dispatch_queue_create("test", DISPATCH_QUEUE_CONCURRENT);
</span><span class='line'>
</span><span class='line'>dispatch_async(q, ^() {printf("A\n");});
</span><span class='line'>dispatch_async(q, ^() {printf("B\n");});
</span><span class='line'>dispatch_async(q, ^() {printf("C\n");});
</span><span class='line'>dispatch_async(q, ^() {printf("D\n");});
</span><span class='line'>
</span><span class='line'>dispatch_barrier_async(q, ^() {printf("barrier\n");});
</span><span class='line'>
</span><span class='line'>dispatch_async(q, ^() {printf("E\n");});
</span><span class='line'>dispatch_async(q, ^() {printf("F\n");});
</span><span class='line'>dispatch_async(q, ^() {printf("G\n");});
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure>


<p>输出结果是:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>A --
</span><span class='line'>C  |  
</span><span class='line'>D  |--&gt; //顺序随机产生
</span><span class='line'>B _|
</span><span class='line'>barrier //这里的输出位置不会变化
</span><span class='line'>F --
</span><span class='line'>E  |--&gt; //顺序随机产生
</span><span class='line'>G --
</span></code></pre></td></tr></table></div></figure>


<p>但是 dispatch_barrier_async 只有提交到自己创建的并发队列时，才有上面的效果。如果是全局队列，或者串行队列，那么 dispatch_barrier_async 和 dispatch_async 是等效的。</p>
</div> -->

  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title" ><a href="/blog/xian-cheng-he-jin-cheng-jian-de-qu-bie/">线程和进程间的区别</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-08-23T15:13:25+08:00'><span class='date'><span class='date-month'>Aug</span> <span class='date-day'>23</span><span class='date-suffix'>rd</span>, <span class='date-year'>2015</span></span> <span class='time'>3:13 pm</span></time>
        
           | <a href="/blog/xian-cheng-he-jin-cheng-jian-de-qu-bie/#disqus_thread"
             data-disqus-identifier="http://tech.dehengxu.com/blog/xian-cheng-he-jin-cheng-jian-de-qu-bie/">Comments</a>
        
      </p>
    
  </header>



<!-- <div class="entry-content"><p><a href="http://www.programmerinterview.com/index.php/operating-systems/thread-vs-process/">译自</a></p>
</div> -->

  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title" ><a href="/blog/timer-hui-diao-shi-jian-bei-uijiao-hu-zu-sai-de-jie-jue-ban-fa/">Timer ⌚回调事件被UI交互阻塞的解决办法</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-08-23T14:59:03+08:00'><span class='date'><span class='date-month'>Aug</span> <span class='date-day'>23</span><span class='date-suffix'>rd</span>, <span class='date-year'>2015</span></span> <span class='time'>2:59 pm</span></time>
        
           | <a href="/blog/timer-hui-diao-shi-jian-bei-uijiao-hu-zu-sai-de-jie-jue-ban-fa/#disqus_thread"
             data-disqus-identifier="http://tech.dehengxu.com/blog/timer-hui-diao-shi-jian-bei-uijiao-hu-zu-sai-de-jie-jue-ban-fa/">Comments</a>
        
      </p>
    
  </header>



<!-- <div class="entry-content"><p>分析原因：</p>

<p>UI 事件运行在主线程，并且UI 事件的运行模式下 runloop 过滤掉了 timer 事件。</p>

<p>回顾一下 runloop 的运行机制我们知道，runloop 是一个处理事件的循环，为了提高效率和隔离事件，它将事件进行了模式划分，通过 Runloop mode 的方式进行分类，并提供了 <code>runMode:beforeDate:</code> 方法 或者 <code>CFRunLoopRunInMode(CFStringRef mode, CFTimeInterval seconds, Boolean returnAfterSourceHandled)</code> 函数。所以 runloop 在 UI 事件进行中，始终运行在 NSRunLoopCommonModes 模式下。</p>

<h3>Runloop 的模式有这几种：</h3>

<p><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html" target="_blank">Runloop modes</a></p>

<h4>Default: NSDefaultRunLoopMode(Cocoa), kCFRunLoopDefaultMode(Core Foundation)</h4>

<blockquote><p>The default mode is the one used for most operations. Most of the time, you should use this mode to start your run loop and configure your input sources.</p></blockquote>

<h4>Connection: NSConnectionReplyMode (Cocoa)</h4>

<blockquote><p>Cocoa uses this mode in conjunction with NSConnection objects to monitor replies. You should rarely need to use this mode yourself.</p></blockquote>

<h4>Modal: NSModalPanelRunLoopMode (Cocoa)</h4>

<blockquote><p>Cocoa uses this mode to identify events intended for modal panels.</p></blockquote>

<h4>Event tracking: NSEventTrackingRunLoopMode (Cocoa)</h4>

<blockquote><p>Cocoa uses this mode to restrict incoming events during mouse-dragging loops and other sorts of user interface tracking loops.</p></blockquote>

<h4>Common modes: NSRunLoopCommonModes (Cocoa), kCFRunLoopCommonModes (Core Foundation)</h4>

<blockquote><p>This is a configurable group of commonly used modes. Associating an input source with this mode also associates it with each of the modes in the group. For Cocoa applications, this set includes the default, modal, and event tracking modes by default. Core Foundation includes just the default mode initially. You can add custom modes to the set using the CFRunLoopAddCommonMode function.</p></blockquote>

<h3>解决方案有以下两种：</h3>

<h4>1. 在其他线程上运行 timer，并在需要的时候将操作发送到主线程</h4>

<p>objc:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
</pre></td><td class='code'><pre><code class='Objective-C'><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">startTimer</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="bp">NSThread</span> <span class="o">*</span><span class="n">th</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">NSThread</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithTarget</span><span class="p">:</span><span class="nb">self</span> <span class="nl">selector</span><span class="p">:</span><span class="k">@selector</span><span class="p">(</span><span class="n">threadRun</span><span class="p">)</span> <span class="nl">object</span><span class="p">:</span><span class="nb">nil</span><span class="p">];</span>
</span><span class='line'>    <span class="p">[</span><span class="n">th</span> <span class="n">start</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">addInfinitTimerToCurrentRunloopWithTarget:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nv">target</span> <span class="nf">selector:</span><span class="p">(</span><span class="kt">SEL</span><span class="p">)</span><span class="nv">selector</span> <span class="nf">inMode:</span><span class="p">(</span><span class="bp">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">mode</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="bp">NSTimer</span> <span class="o">*</span><span class="n">timer</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSTimer</span> <span class="nl">timerWithTimeInterval</span><span class="p">:</span><span class="mf">1.0</span> <span class="nl">target</span><span class="p">:</span><span class="nb">self</span> <span class="nl">selector</span><span class="p">:</span><span class="k">@selector</span><span class="p">(</span><span class="nl">timerRun</span><span class="p">:)</span> <span class="nl">userInfo</span><span class="p">:</span><span class="nb">nil</span> <span class="nl">repeats</span><span class="p">:</span><span class="nb">YES</span><span class="p">];</span>
</span><span class='line'>    <span class="p">[[</span><span class="bp">NSRunLoop</span> <span class="n">currentRunLoop</span><span class="p">]</span> <span class="nl">addTimer</span><span class="p">:</span><span class="n">timer</span> <span class="nl">forMode</span><span class="p">:</span><span class="n">mode</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">threadRun</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="p">[</span><span class="nb">self</span> <span class="nl">addInfinitTimerToCurrentRunloopWithTarget</span><span class="p">:</span><span class="nb">self</span> <span class="nl">selector</span><span class="p">:</span><span class="k">@selector</span><span class="p">(</span><span class="nl">timerRun</span><span class="p">:)</span> <span class="nl">inMode</span><span class="p">:</span><span class="s">@&quot;MyTimerMode&quot;</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">while</span> <span class="p">(</span><span class="nb">YES</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;%s while..&quot;</span><span class="p">,</span> <span class="n">__FUNCTION__</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>        <span class="p">[[</span><span class="bp">NSRunLoop</span> <span class="n">currentRunLoop</span><span class="p">]</span> <span class="nl">runMode</span><span class="p">:</span><span class="s">@&quot;MyTimerMode&quot;</span> <span class="nl">beforeDate</span><span class="p">:[</span><span class="bp">NSDate</span> <span class="n">distantFuture</span><span class="p">]];</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">timerRun:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nv">sender</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;~&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="p">[</span><span class="nb">self</span> <span class="nl">performSelectorOnMainThread</span><span class="p">:</span><span class="k">@selector</span><span class="p">(</span><span class="n">someSelector</span><span class="p">)</span> <span class="nl">withObject</span><span class="p">:</span><span class="nb">nil</span> <span class="nl">waitUntilDone</span><span class="p">:</span><span class="nb">YES</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">someSelector</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="c1">//....</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这里用 NSThread 和自定义的计时器模式 <code>@"MyTimerMode"</code> 来实现。</p>

<h4>2.在主线程加入计时器</h4>

<p>objc:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='Objective-C'><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">addInfinitTimerToCurrentRunloopWithTarget:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nv">target</span> <span class="nf">selector:</span><span class="p">(</span><span class="kt">SEL</span><span class="p">)</span><span class="nv">selector</span> <span class="nf">inMode:</span><span class="p">(</span><span class="bp">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">mode</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="bp">NSTimer</span> <span class="o">*</span><span class="n">timer</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSTimer</span> <span class="nl">timerWithTimeInterval</span><span class="p">:</span><span class="mf">1.0</span> <span class="nl">target</span><span class="p">:</span><span class="nb">self</span> <span class="nl">selector</span><span class="p">:</span><span class="k">@selector</span><span class="p">(</span><span class="nl">timerRun</span><span class="p">:)</span> <span class="nl">userInfo</span><span class="p">:</span><span class="nb">nil</span> <span class="nl">repeats</span><span class="p">:</span><span class="nb">YES</span><span class="p">];</span>
</span><span class='line'>    <span class="p">[[</span><span class="bp">NSRunLoop</span> <span class="n">currentRunLoop</span><span class="p">]</span> <span class="nl">addTimer</span><span class="p">:</span><span class="n">timer</span> <span class="nl">forMode</span><span class="p">:</span><span class="n">mode</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//运行在主线程上</span>
</span><span class='line'>
</span><span class='line'><span class="p">[</span><span class="nb">self</span> <span class="nl">addInfinitTimerToCurrentRunloopWithTarget</span><span class="p">:</span><span class="nb">self</span> <span class="nl">selector</span><span class="p">:</span><span class="k">@selector</span><span class="p">(</span><span class="nl">timerRun</span><span class="p">:)</span> <span class="nl">inMode</span><span class="p">:</span><span class="n">NSRunLoopCommonModes</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p>让 timer 所运行的 Runloop mode 和UI 滚动事件的 Runloop mode 一致即可。</p>
</div> -->

  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title" ><a href="/blog/tong-guo-clang-fen-xi-block-de-ji-zhi/">通过 Clang 分析 Block 的机制</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-08-23T08:35:18+08:00'><span class='date'><span class='date-month'>Aug</span> <span class='date-day'>23</span><span class='date-suffix'>rd</span>, <span class='date-year'>2015</span></span> <span class='time'>8:35 am</span></time>
        
           | <a href="/blog/tong-guo-clang-fen-xi-block-de-ji-zhi/#disqus_thread"
             data-disqus-identifier="http://tech.dehengxu.com/blog/tong-guo-clang-fen-xi-block-de-ji-zhi/">Comments</a>
        
      </p>
    
  </header>



<!-- <div class="entry-content"><h3>简单看一下编译器对 __block 做了什么</h3>

<h4>1. 普通变量在栈空间上</h4>

<p>objc:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)useBlock
</span><span class='line'>{
</span><span class='line'>  int  = 2;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>c++:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static void _I_Block4Clang_useBlock(Block4Clang * self, SEL _cmd) {
</span><span class='line'>    int i = 2;
</span><span class='line'>
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<blockquote><p>很简单的处理——没有任何处理，变量依然分配在了栈空间上。</p></blockquote>

<h4>2. __block 修饰的变量</h4>

<p>objc:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)useBlock
</span><span class='line'>{
</span><span class='line'>  int __block i = 2;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>c++:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>struct __Block_byref_i_0 {
</span><span class='line'>  void *__isa;
</span><span class='line'>__Block_byref_i_0 *__forwarding;
</span><span class='line'> int __flags;
</span><span class='line'> int __size;
</span><span class='line'> int i;
</span><span class='line'>};
</span><span class='line'>
</span><span class='line'>static void _I_Block4Clang_useBlock(Block4Clang * self, SEL _cmd) {
</span><span class='line'>    __attribute__((__blocks__(byref))) __Block_byref_i_0 i = {(void*)0,(__Block_byref_i_0 *)&i, 0, sizeof(__Block_byref_i_0), 2};
</span><span class='line'>
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<p>我们看到如果是 block 修饰的变量，虽然定义在在栈空间上，但是编译器会将它分配到堆的空间上(编译器的做法是，通过 <code>__Block_byref_i_0</code> 结构来封装变量 <code>i</code>)，这样的好处是 block 可以通过 <code>__Block_byref_i_0 *</code> 指针访问堆上的变量 i 了。</p>

<h3>再看一下编译器对 block 做了什么</h3>

<h4>1. 空 block。</h4>

<p>objc:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)useBlock
</span><span class='line'>{
</span><span class='line'>  ^(){};
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>c++:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//这是 block 的c++定义
</span><span class='line'>struct __Block4Clang__useBlock_block_impl_0 {
</span><span class='line'>  //这是 block 实现的结构体类型
</span><span class='line'>  struct __block_impl impl;
</span><span class='line'>  //这是 block 描述信息的结构体类型
</span><span class='line'>  struct __Block4Clang__useBlock_block_desc_0* Desc;
</span><span class='line'>
</span><span class='line'>  //这是构造函数
</span><span class='line'>  __Block4Clang__useBlock_block_impl_0(void *fp, struct __Block4Clang__useBlock_block_desc_0 *desc, int flags=0) {
</span><span class='line'>      //指明了 block 类型(分配在栈上的block)
</span><span class='line'>    impl.isa = &_NSConcreteStackBlock;
</span><span class='line'>    impl.Flags = flags;
</span><span class='line'>    //对应的函数指针，这才是实际执行的代码
</span><span class='line'>    impl.FuncPtr = fp;
</span><span class='line'>    //block描述体，包含了数据信息
</span><span class='line'>    Desc = desc;
</span><span class='line'>  }
</span><span class='line'>};
</span><span class='line'>
</span><span class='line'>/**
</span><span class='line'> * block 被转成的 c++ 函数定义
</span><span class='line'> * struct __Block4Clang__useBlock_block_impl_0 *__cself 指向 block 对象本身
</span><span class='line'> */
</span><span class='line'>static void __Block4Clang__useBlock_block_func_0(struct __Block4Clang__useBlock_block_impl_0 *__cself) {
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>    }
</span><span class='line'>//block 描述信息的结构申明
</span><span class='line'>static struct __Block4Clang__useBlock_block_desc_0 {
</span><span class='line'>  size_t reserved;
</span><span class='line'>  size_t Block_size;
</span><span class='line'>} __Block4Clang__useBlock_block_desc_0_DATA = { 0, sizeof(struct __Block4Clang__useBlock_block_impl_0)};
</span><span class='line'>
</span><span class='line'>//实际调用 block 的函数
</span><span class='line'>static void _I_Block4Clang_useBlock(Block4Clang * self, SEL _cmd) {
</span><span class='line'>
</span><span class='line'>    ((void (*)())&__Block4Clang__useBlock_block_impl_0((void *)__Block4Clang__useBlock_block_func_0, &__Block4Clang__useBlock_block_desc_0_DATA));
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h4>2.引用栈变量并修改它</h4>

<p>objc:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)useBlock
</span><span class='line'>{
</span><span class='line'>    __block int i = 2;
</span><span class='line'>    ^(){
</span><span class='line'>        i = 8;
</span><span class='line'>    };
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>c++:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct __Block_byref_i_0 {
</span><span class='line'>  void *__isa;
</span><span class='line'>__Block_byref_i_0 *__forwarding;
</span><span class='line'> int __flags;
</span><span class='line'> int __size;
</span><span class='line'> int i;
</span><span class='line'>};
</span><span class='line'>
</span><span class='line'>struct __Block4Clang__useBlock_block_impl_0 {
</span><span class='line'>  struct __block_impl impl;
</span><span class='line'>  struct __Block4Clang__useBlock_block_desc_0* Desc;
</span><span class='line'>
</span><span class='line'>  //i 变量被封装到了 __Block_byref_i_0 结构内部
</span><span class='line'>  __Block_byref_i_0 *i; // by ref
</span><span class='line'>  __Block4Clang__useBlock_block_impl_0(void *fp, struct __Block4Clang__useBlock_block_desc_0 *desc, __Block_byref_i_0 *_i, int flags=0) : i(_i-&gt;__forwarding) {
</span><span class='line'>    impl.isa = &_NSConcreteStackBlock;
</span><span class='line'>    impl.Flags = flags;
</span><span class='line'>    impl.FuncPtr = fp;
</span><span class='line'>    Desc = desc;
</span><span class='line'>  }
</span><span class='line'>};
</span><span class='line'>static void __Block4Clang__useBlock_block_func_0(struct __Block4Clang__useBlock_block_impl_0 *__cself) {
</span><span class='line'>  __Block_byref_i_0 *i = __cself-&gt;i; // bound by ref
</span><span class='line'>          //访问堆上的变量i，达到 block 可以修改被引用的变量的目的。
</span><span class='line'>        (i-&gt;__forwarding-&gt;i) = 8;
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>/*这里增加了一个 copy 函数，和 dispose 函数，分别用来复制 block 到堆中，释放堆上的 block 对象。*/
</span><span class='line'>
</span><span class='line'>//通过  _Block_object_assign 将src-&gt;i 内容复制到 dst-&gt;i（我们可以推测，src 就是栈上的空间，dst就是堆上的空间，只有这样才能解释当 useBlock 的生命周期结束后，为什么 block 依然还能够执行）
</span><span class='line'>static void __Block4Clang__useBlock_block_copy_0(struct __Block4Clang__useBlock_block_impl_0*dst, struct __Block4Clang__useBlock_block_impl_0*src) {_Block_object_assign((void*)&dst-&gt;i, (void*)src-&gt;i, 8/*BLOCK_FIELD_IS_BYREF*/);}
</span><span class='line'>//dispose 工具函数通过 _Block_object_dispose 来释放 src-&gt;i
</span><span class='line'>static void __Block4Clang__useBlock_block_dispose_0(struct __Block4Clang__useBlock_block_impl_0*src) {_Block_object_dispose((void*)src-&gt;i, 8/*BLOCK_FIELD_IS_BYREF*/);}
</span><span class='line'>
</span><span class='line'>static struct __Block4Clang__useBlock_block_desc_0 {
</span><span class='line'>  size_t reserved;
</span><span class='line'>  size_t Block_size;
</span><span class='line'>  void (*copy)(struct __Block4Clang__useBlock_block_impl_0*, struct __Block4Clang__useBlock_block_impl_0*);
</span><span class='line'>  void (*dispose)(struct __Block4Clang__useBlock_block_impl_0*);
</span><span class='line'>} __Block4Clang__useBlock_block_desc_0_DATA = { 0, sizeof(struct __Block4Clang__useBlock_block_impl_0), __Block4Clang__useBlock_block_copy_0, __Block4Clang__useBlock_block_dispose_0};
</span><span class='line'>
</span><span class='line'>//编译器将 useBlock 方法，转换成了 c++ 函数，和runtime的风格一样
</span><span class='line'>static void _I_Block4Clang_useBlock(Block4Clang * self, SEL _cmd) {
</span><span class='line'>  //在这里将 i 封装到了 __Block_byref_i_0 结构中
</span><span class='line'>    __attribute__((__blocks__(byref))) __Block_byref_i_0 i = {(void*)0,(__Block_byref_i_0 *)&i, 0, sizeof(__Block_byref_i_0), 2};
</span><span class='line'>    //这里才最终执行了 block 调用过程，并将函数指针(__Block4Clang__useBlock_block_func_0)，数据描述指针(&__Block4Clang__useBlock_block_desc_0_DATA)，数据封装(&i，这里的 i 是 __Block_byref_i_0 对象地址)
</span><span class='line'>    ((void (*)())&__Block4Clang__useBlock_block_impl_0((void *)__Block4Clang__useBlock_block_func_0, &__Block4Clang__useBlock_block_desc_0_DATA, (__Block_byref_i_0 *)&i, 570425344));
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h4>3.引用栈变量，但不修改它</h4>

<p>objc:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)useBlock
</span><span class='line'>{
</span><span class='line'>    int i = 2;
</span><span class='line'>    ^(){
</span><span class='line'>        int j = i;
</span><span class='line'>        j++;
</span><span class='line'>        printf("i = %d, j = %d\n", i, j);
</span><span class='line'>    }();
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>c++:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct __Block4Clang__useBlock_block_impl_0 {
</span><span class='line'>  struct __block_impl impl;
</span><span class='line'>  struct __Block4Clang__useBlock_block_desc_0* Desc;
</span><span class='line'>  int i;
</span><span class='line'>  __Block4Clang__useBlock_block_impl_0(void *fp, struct __Block4Clang__useBlock_block_desc_0 *desc, int _i, int flags=0) : i(_i) {
</span><span class='line'>    impl.isa = &_NSConcreteStackBlock;
</span><span class='line'>    impl.Flags = flags;
</span><span class='line'>    impl.FuncPtr = fp;
</span><span class='line'>    Desc = desc;
</span><span class='line'>  }
</span><span class='line'>};
</span><span class='line'>static void __Block4Clang__useBlock_block_func_0(struct __Block4Clang__useBlock_block_impl_0 *__cself) {
</span><span class='line'>  int i = __cself-&gt;i; // bound by copy
</span><span class='line'>
</span><span class='line'>        int j = i;
</span><span class='line'>        j++;
</span><span class='line'>        printf("i = %d, j = %d\n", i, j);
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>static struct __Block4Clang__useBlock_block_desc_0 {
</span><span class='line'>  size_t reserved;
</span><span class='line'>  size_t Block_size;
</span><span class='line'>} __Block4Clang__useBlock_block_desc_0_DATA = { 0, sizeof(struct __Block4Clang__useBlock_block_impl_0)};
</span><span class='line'>
</span><span class='line'>static void _I_Block4Clang_useBlock(Block4Clang * self, SEL _cmd) {
</span><span class='line'>    int i = 2;
</span><span class='line'>    ((void (*)())&__Block4Clang__useBlock_block_impl_0((void *)__Block4Clang__useBlock_block_func_0, &__Block4Clang__useBlock_block_desc_0_DATA, i))();
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>



</div> -->

  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title" ><a href="/blog/guan-li-zi-you-qiao-jie-toll-free-bridging/">管理自由桥接(Toll-Free Bridging)</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-08-22T18:21:12+08:00'><span class='date'><span class='date-month'>Aug</span> <span class='date-day'>22</span><span class='date-suffix'>nd</span>, <span class='date-year'>2015</span></span> <span class='time'>6:21 pm</span></time>
        
           | <a href="/blog/guan-li-zi-you-qiao-jie-toll-free-bridging/#disqus_thread"
             data-disqus-identifier="http://tech.dehengxu.com/blog/guan-li-zi-you-qiao-jie-toll-free-bridging/">Comments</a>
        
      </p>
    
  </header>



<!-- <div class="entry-content"><p>在很多 Cocoa 应用程序中，你需要使用 Core Foundation 风格的对象，有的来自 Core Foundation 框架自己(像：<a href="https://developer.apple.com/library/ios/documentation/CoreFoundation/Reference/CFArrayRef/index.html#//apple_ref/c/tdef/CFArrayRef">CFArrayRef</a> 或 <a href="https://developer.apple.com/library/ios/documentation/CoreFoundation/Reference/CFMutableDictionaryRef/index.html#//apple_ref/c/tdef/CFMutableDictionaryRef">CFMutaleDictionaryRef</a>) 或者来自于适配了 Core Foudation 大会例如 Core Graphics (你可能使用这些类型：<a href="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Reference/CGColorSpace/index.html#//apple_ref/c/tdef/CGColorSpaceRef">CGColorSpaceRef</a> 和  <a href="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Reference/CGGradient/index.html#//apple_ref/c/tdef/CGGradientRef">CGGradientRef</a>)。</p>

<p>编译器不会自动管理 Core Foundation 对象的生命期；你必须调用 <a href="https://developer.apple.com/library/ios/documentation/CoreFoundation/Reference/CFTypeRef/index.html#//apple_ref/c/func/CFRetain">CFRetain</a> 和 <a href="https://developer.apple.com/library/ios/documentation/CoreFoundation/Reference/CFTypeRef/index.html#//apple_ref/c/func/CFRelease">CFRelease</a> (或者响应类型指定的变体) 就像 Core Foundation 内存管理规则中描述的(见 <a href="https://developer.apple.com/library/ios/documentation/CoreFoundation/Conceptual/CFMemoryMgmt/CFMemoryMgmt.html#//apple_ref/doc/uid/10000127i">Memory Management Programming</a>)。</p>

<p>如果你在 Objective-C 和 Core Foundation 风格对象之间互相转换，你需要告诉编译器使用转换(定义在 objc/runtime.h中)或者 Core Foundation 风格的宏(定义在 NSObjecti.h中) 对象所拥有的的语义关系:</p>

<ul>
<li><p>__bridge 在 Objective-C 和 Core Foundation 之间转换指针，而不需要传递所有权。</p></li>
<li><p>__bridge_retained 或 CFBridgingRetain 转换 Objective-C 指针为 Core Foundation 指针，并且传递对象所有权给你，你负责进行 CFRelease 调用，或者调用相关的函数释放对象所有权。</p></li>
<li><p>__bridge_transfer 或 CFBridgingRelease 移动非 Objective-C 指针到 Objective-C ，同时传递所有权到 ARC。 ARC 负责释放对象的所有权。</p></li>
</ul>


<p>举个例子，如果你曾经这样写过代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)logFirstNameOfPerson:(ABRecordRef)person {
</span><span class='line'> 
</span><span class='line'>    NSString *name = (NSString *)ABRecordCopyValue(person, kABPersonFirstNameProperty);
</span><span class='line'>    NSLog(@"Person's first name: %@", name);
</span><span class='line'>    [name release];
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>你可以替换成：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)logFirstNameOfPerson:(ABRecordRef)person {
</span><span class='line'> 
</span><span class='line'>    NSString *name = (NSString *)CFBridgingRelease(ABRecordCopyValue(person, kABPersonFirstNameProperty));
</span><span class='line'>    NSLog(@"Person's first name: %@", name);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h3>编译器处理从 Cocoa 方法中返回的 CF 对象</h3>

<p>编译器根据历史上的 Cocoa 命名规则理解那些返回 Core Foundation 类型的 Objective-C 方法(见: <a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/MemoryMgmt/Articles/MemoryMgmt.html#//apple_ref/doc/uid/10000011i">Advanced Memory Management Programming Guide</a>)。例如，编译器知道,iOS 中 CGColor 通过 <a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIColor_Class/index.html#//apple_ref/occ/cl/UIColor">UIColor</a> 的 <a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIColor_Class/index.html#//apple_ref/occ/instp/UIColor/CGColor">CGColor</a> 方法返回的对象不属于这个规则。你必须使用合适的类型转换，看下面的代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>NSMutableArray *colors = [NSMutableArray arrayWithObject:(id)[[UIColor darkGrayColor] CGColor]];
</span><span class='line'>[colors addObject:(id)[[UIColor lightGrayColor] CGColor]];</span></code></pre></td></tr></table></div></figure>



</div> -->

  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/posts/5">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/posts/3">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/use-jenkins-with-self-organizing-swarm-plug-in-modules/">Use Jenkins With Self Organizing Swarm Plug in Modules</a>
      </li>
    
      <li class="post">
        <a href="/blog/ios-mapping-lib/">iOS Mapping Lib</a>
      </li>
    
      <li class="post">
        <a href="/blog/web-protocol-collection/">Web Protocol Collection</a>
      </li>
    
      <li class="post">
        <a href="/blog/app-transport-security-ji-zhu/">App Transport Security 技术</a>
      </li>
    
      <li class="post">
        <a href="/blog/android-chang-yong-di-san-fang-ku/">Android 常用第三方库</a>
      </li>
    
      <li class="post">
        <a href="/blog/mqtt-resources/">MQTT Resources</a>
      </li>
    
      <li class="post">
        <a href="/blog/shi-yong-guo-nei-yuan-ti-gao-android-sdk-manager-su-du/">使用国内源提高Android SDK Manager 速度</a>
      </li>
    
      <li class="post">
        <a href="/blog/di-san-fang-xiao-xi-tui-song-fu-wu-dui-bi/">第三方消息推送服务对比</a>
      </li>
    
      <li class="post">
        <a href="/blog/diagram-of-a-activitys-life-cycle/">Diagram of a Activity's Life Cycle</a>
      </li>
    
      <li class="post">
        <a href="/blog/bash-usage/">Bash Usage</a>
      </li>
    
      <li class="post">
        <a href="/blog/useful-tools-for-xcode/">Useful Tools for Xcode</a>
      </li>
    
      <li class="post">
        <a href="/blog/ios-chang-yong-di-san-fang-ku/">iOS 常用第三方库</a>
      </li>
    
      <li class="post">
        <a href="/blog/gitsh-de-an-zhuang-he-shi-yong/">Gitsh 的安装和使用</a>
      </li>
    
      <li class="post">
        <a href="/blog/shi-yong-cocoapods-lai-guan-li-ji-yu-svn-de-zi-xiang-mu/">使用 Cocoapods 来管理基于 Svn 的子项目</a>
      </li>
    
      <li class="post">
        <a href="/blog/create-a-private-pods/">Create a Private Pods</a>
      </li>
    
      <li class="post">
        <a href="/blog/use-cocoapods-publish-your-podspec/">Use Cocoapods Publish Your Podspec</a>
      </li>
    
      <li class="post">
        <a href="/blog/objc-msgsend-bian-yi-cuo-wu-de-jie-jue-fang-fa/">Runtime 在新版本 Xcode 中引起的编译错误，及解决方法</a>
      </li>
    
      <li class="post">
        <a href="/blog/zi-ding-yi-lei-ru-he-ti-gong-kvc-jian-rong-te-xing/">自定义类如何提供 KVC 兼容特性</a>
      </li>
    
      <li class="post">
        <a href="/blog/shi-yong-nsvalue-feng-zhuang-ren-yi-jie-gou-ti/">使用 NSValue 封装任意结构体</a>
      </li>
    
      <li class="post">
        <a href="/blog/kvo-ji-zhi/">KVO 机制</a>
      </li>
    
  </ul>
</section>

<section>
  <h1>About Me</h1>
  <p>I'm focusing on iOS techs, and interested in web technologies.</p>
  <p><a href="mailto:dehengxu@outlook.com?subject=咱们认识一下吧">dehengxu@outlook.com</a></p>
  <p>QQ:36764672</p>
</section>

  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2015 - Deheng Xu -
  <span class="credit">Powered by <a href="http://octopress.org" target="_blank">Octopress</a></span>
  <span class="credit"><a href="https://github.com/xudeheng" target="_blank">@github</a></span>
	<span class="credit"><a href="https://twitter.com/dehengxu" target="_blank">@twitter</a></span>
	<span class="credit"><a href="https://github.com/xudeheng/ios_tech_octopress" target="_blank">source</a></span>
  <span class="credit"><a href="http://www.dehengxu.com/" target="_blank">MyBase</a></span>
  <span class="credit"><a href="http://jekyllrb.com/docs/home" target="_blank">JekyllDocs</a></span>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'headwindx';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>











</body>
</html>
