
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>逆风@[iOS,nil]</title>
  <meta name="author" content="Deheng Xu">

  
  <meta name="description" content="KVO 机制 Aug 28th, 2015 6:36 pm KVC 机制 Aug 28th, 2015 5:16 pm Use Dispatch Source Timer Aug 27th, 2015 4:58 pm Bash 使用技巧 Aug 23rd, 2015 11:11 pm GCD &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://ios.dehengxu.com/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="逆风@[iOS,nil]" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>

  <!--<script src="/javascript/search.min.js" type="text/javascript" charset="utf-8"></script> -->

  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">逆风@[iOS,nil]</a></h1>
  
    <h2>A blog focus on iOS techs.</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="sitesearch" value="ios.dehengxu.com">
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title" ><a href="/blog/2015/08/28/kvo-ji-zhi/">KVO 机制</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-08-28T18:36:18+08:00'><span class='date'><span class='date-month'>Aug</span> <span class='date-day'>28</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>6:36 pm</span></time>
        
      </p>
    
  </header>



<!-- <div class="entry-content"><h2>KVO : 键值观察 (Key-value observing)</h2>

<p>KVO 是一个允许一个对象直接接受来自另一个对象属性改变时发送的通知的机制。KVO 能成为应用内部重要的因素。它是采用了MVC设计模式的应用程序中对象间的一种通信模式。比如，你可以使用它来同步 view 和 controller 层中模型对象之间的状态。典型情况下，控制器对象观察模型对象，试图对象观察控制器对象或者模型对象。</p>

<blockquote><p>注意：虽然 UIKit 框架通常不支持 KVO，你仍然能够在自定义的对象中实现它，包括自定义的视图。</p></blockquote>

<p><img src="http://ios.dehengxu.com/images/refered/kvo.jpg" alt="kvo" /></p>

<p>使用 KVO，一个对象可以观察另一个对象的任意的属性，包括简单的附属值，对一的关系和对多的关系。一个对象能找出当前属性先前的值。对多关系的观察者被通告的内容不仅有类型的改变，也被告知哪个对象在改变中被调用。</p>

<p>作为一个通知机制，KVO 和 <code>NSNotification</code> 和 <code>NSNotificationCenter</code> 提供的机制类似，但是也有一些明显的不同。不同于中央对象来对所有注册为观察者的对象广播通知，当属性值的改变发生时，KVO 通知直接发送给观察对象。</p>

<h3>实现 KVO</h3>

<p>根类 <code>NSObject</code>，提供了基本的 KVO 实现，你很少需要重载它。因此所有的 Cocoa objects 都继承了 KVO 的能力。你必须按照这些步骤来接收某个属性的 KVO 通知。</p>

<ul>
<li><p>你必须确保被观察的类对于你想观察的属性是符合 KVO 规范。 KVO 兼容性需要被观察对象的类也是 KVO 兼容的，而且也允许为该属性自动发送观察者通知，或者手动实现该属性的 KVO 。</p></li>
<li><p>添加一个观察者到一个值会发生改变的对象。你可以通过调用 <code>addObserver:forKeyPath:optios:context:</code> 来达到这个目的。观察者是应用中的另一个对象。</p></li>
<li><p>在观察者对象中，实现方法 <code>observeValueForKeyPath:ofObject:change:context:</code> 。当被观察对象的属性值发生改变的时候这个方法会被调用。</p></li>
</ul>


<h3>KVO 是绑定(OS X)的必须部分</h3>

<p>Cocoa 绑定是一个允许你不用写一些胶水代码就能确保模型中的值和你应用程序中的视图层同步的 OS X 技术。通过 Interface Builder 检查器中，你就能在视图属性和一些数据之间建立起协调链接，“绑定”他们就像其中一个发生改变会在其他身上反映出来。KVO，和 KVC 还有 KVB 都是 Cocoa 绑定的基础技术。</p>

<h3>前提文章</h3>

<p><a href="https://developer.apple.com/library/ios/documentation/General/Conceptual/DevPedia-CocoaCore/KeyValueCoding.html#//apple_ref/doc/uid/TP40008195-CH25-SW1">Key-value coding</a></p>

<h3>相关的文章</h3>

<p><a href="https://developer.apple.com/library/ios/documentation/General/Conceptual/DevPedia-CocoaCore/MVC.html#//apple_ref/doc/uid/TP40008195-CH32-SW1">Model-View-Controller</a></p>

<p><a href="https://developer.apple.com/library/ios/documentation/General/Conceptual/DevPedia-CocoaCore/DynamicBinding.html#//apple_ref/doc/uid/TP40008195-CH15-SW1">Dynamic binding</a></p>

<h3>权威论述</h3>

<p><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/KeyValueObserving/KeyValueObserving.html#//apple_ref/doc/uid/10000177i">Key-value Observing Programming Guide</a></p>

<p><a href="https://developer.apple.com/library/ios/documentation/General/Conceptual/DevPedia-CocoaCore/KVO.html#//apple_ref/doc/uid/TP40008195-CH16-SW1">Ref</a></p>
</div> -->

  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title" ><a href="/blog/2015/08/28/kvc-ji-zhi/">KVC 机制</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-08-28T17:16:18+08:00'><span class='date'><span class='date-month'>Aug</span> <span class='date-day'>28</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>5:16 pm</span></time>
        
      </p>
    
  </header>



<!-- <div class="entry-content"><h2>KVC : 键值编码 (Key-value coding)</h2>

<p>键值编码是一个通过字符串间接访问对象属性和关系的机制。它是 Cocoa编程中一些机制和技术的基石，在他们中间 Core Data, 应用程序脚本能力, 绑定技术，还有语言特性中的属性声明。 (脚本特性和绑定是指 OS X 上的 Cocoa。) 你也能使用键值编码来简化你的程序代码。</p>

<h3>对象属性和 KVC</h3>

<p>KVC 的核心是属性的通用概念。一个属性对应一个对象封装的状态单元。属性可以是这两种类型中的一个：一个属性(例如：name, subtotal, 或者 textColor) 或者相对于其他对象的关系。关系既可以是 一对一，也可以是一对多。一对多关系的值通常是一个数组或者集合，取决于关系是否有序。</p>

<p>KVC 通过“键”来定位对象的属性，其实就是一个字符串标识。“键”常常代表一个访问器方法或者实例变量的名字。“键”必须符合某种规则：必须是 ASCII 编码，小写字母开头，还没有空格。Key path是由点与“键”分隔的字符串，它被用来指明一系列对象属性的链式访问。序列的第一个“键”是相对于指定的对象来说的(如下面图表中的 employee1)，并且每个子序列“键”是相对于前一个属性值来的。</p>

<p><img src="http://ios.dehengxu.com/images/refered/key_value_coding.jpg" alt="sample" /></p>

<h3>使类支持 KVC</h3>

<p>NSKeyValueCoding 非正式的协议使 KVC 成为可能。其中两个方法： <code>valueForKey:</code> 和 <code>setValue:forKey:</code> 是特殊且重要的方法，应为他们能获取，设置给定 “键” 的属性值。 <code>NSObject</code> 为这两个方法提供了默认实现，并且如果类和 KVC 兼容，它可以依赖这个实现。</p>

<p>你如何实现属性 KVC 的兼容性，依赖于属性是一个附属值，一对多或者一对一的关系。对于附属值，一对一关系来说，类必须至少实现一个以下给定顺序的配置(键 和属性的键关联)：</p>

<ol>
<li>类使用“键”的名字来声明属性</li>
<li>实现了以“键”命名的访问器，如果属性是可修改的，<code>setKey:</code>(如果属性是一个布尔值，<code>getter</code>访问起方法有 <code>isKey</code> 有形式。)</li>
<li>声明了 <code>key</code> 或者 <code>_key</code>形式的实例变量。</li>
</ol>


<blockquote><p>PS: 这里我认为 <code>attribute</code>叫做附属值或者值，<code>property</code>称作属性更恰当。一般来说 attrubute 比 property 要轻量级一些。</p></blockquote>

<p>实现对多的 KVC 兼容是一个更复杂的过程。可以参考权关于 KVC 威性的文档来学习实现的过程。</p>

<h3>前提文章</h3>

<p><a href="https://developer.apple.com/library/ios/documentation/General/Conceptual/DevPedia-CocoaCore/ObjectModeling.html#//apple_ref/doc/uid/TP40008195-CH41-SW1">Object modeling</a></p>

<p><a href="https://developer.apple.com/library/ios/documentation/General/Conceptual/DevPedia-CocoaCore/AccessorMethod.html#//apple_ref/doc/uid/TP40008195-CH2-SW1">Accessor method</a></p>

<h3>相关文章</h3>

<p><a href="https://developer.apple.com/library/ios/documentation/General/Conceptual/DevPedia-CocoaCore/DeclaredProperty.html#//apple_ref/doc/uid/TP40008195-CH13-SW1">Declared property</a></p>

<h3>权威论述</h3>

<p><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/KeyValueCoding/Articles/KeyValueCoding.html#//apple_ref/doc/uid/10000107i">Key-value Coding Programming Guide</a></p>

<p><a href="https://developer.apple.com/library/ios/documentation/General/Conceptual/DevPedia-CocoaCore/KeyValueCoding.html#//apple_ref/doc/uid/TP40008195-CH25-SW1">https://developer.apple.com/library/ios/documentation/General/Conceptual/DevPedia-CocoaCore/KeyValueCoding.html#//apple_ref/doc/uid/TP40008195-CH25-SW1</a></p>
</div> -->

  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title" ><a href="/blog/2015/08/27/use-dispatch-source-timer/">Use Dispatch Source Timer</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-08-27T16:58:03+08:00'><span class='date'><span class='date-month'>Aug</span> <span class='date-day'>27</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>4:58 pm</span></time>
        
      </p>
    
  </header>



<!-- <div class="entry-content"><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>dispatch_queue_t queue = dispatch_queue_create("com.xxx.timer", DISPATCH_QUEUE_CONCURRENT);
</span><span class='line'>
</span><span class='line'>dispatch_source_t timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue);
</span><span class='line'>
</span><span class='line'>dispatch_source_set_timer(timer, DISPATCH_TIME_NOW, 1 * NSEC_PER_SEC, NSEC_PER_SEC / 10);
</span><span class='line'>
</span><span class='line'>// 设置定时器回调 block
</span><span class='line'>dispatch_source_set_event_handler(timer, ^ {
</span><span class='line'>  //do something...
</span><span class='line'>});
</span><span class='line'>
</span><span class='line'>dispatch_resume(timer);
</span></code></pre></td></tr></table></div></figure>


<p>关键点： timer 一定要被 retain ，防止提前释放，否则 timer 无效。</p>

<p>关闭 timer 可以使用 <code>dispatch_source_cancel</code> 函数。</p>
</div> -->

  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title" ><a href="/blog/2015/08/23/bash-shi-yong-ji-qiao/">Bash 使用技巧</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-08-23T23:11:02+08:00'><span class='date'><span class='date-month'>Aug</span> <span class='date-day'>23</span><span class='date-suffix'>rd</span>, <span class='date-year'>2015</span></span> <span class='time'>11:11 pm</span></time>
        
      </p>
    
  </header>



<!-- <div class="entry-content"><h4>递归搜索目录下所有文件内容</h4>

<p>bash</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>ls ./**/*.ext | xargs grep algorit</span></code></pre></td></tr></table></div></figure>


<blockquote><p>搜索当前目录下所有的 ext 文件，并且匹配是否包含关键词 <code>algorit</code></p></blockquote>

<h4>查找进程</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>es -ef|grep name</span></code></pre></td></tr></table></div></figure>


<blockquote><p>查找进程名包含 <code>name</code> 的进程</p></blockquote>

<h4>查看开启的端口</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>lsof -i:8080</span></code></pre></td></tr></table></div></figure>


<blockquote><p>查看使用端口 8080 的进程</p></blockquote>
</div> -->

  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title" ><a href="/blog/2015/08/23/gcd-de-chang-gui-yong-fa/">GCD 的常规用法</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-08-23T15:56:50+08:00'><span class='date'><span class='date-month'>Aug</span> <span class='date-day'>23</span><span class='date-suffix'>rd</span>, <span class='date-year'>2015</span></span> <span class='time'>3:56 pm</span></time>
        
      </p>
    
  </header>



<!-- <div class="entry-content"><p>GCD 通过将多线程抽象为 <code>dispatch_queue_t</code> 类型的对象，以 Block 作为计算单元实现的一套基于 C 语言的开源多线程库 <code>libdispatch</code>。</p>

<p>GCD 让多线程开发变的更加方便，简洁。</p>

<p>首先明确几个 GCD 中的特性:</p>

<ol>
<li>全局队列都是异步的。</li>
<li>主队列是同步的。</li>
<li>串行队列中在当前上下文执行同步计算会产生死锁。</li>
</ol>


<h3>创建并行，串行队列</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>dispatch_queue_create("q1", DISPATCH_QUEUE_CONCURRENT);</span></code></pre></td></tr></table></div></figure>




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>dispatch_queue_create("q1", DISPATCH_QUEUE_SERIAL);</span></code></pre></td></tr></table></div></figure>


<h3>异步执行任务</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>disaptch_async(queue, ^() {
</span><span class='line'>  //Todo....
</span><span class='line'>});</span></code></pre></td></tr></table></div></figure>


<h3>同步执行任务的方式</h3>

<ol>
<li><p>dispatch_semaphor_t</p>

<pre><code>dispatch_semaphor_t semaphor = disaptch_semaphor_create(1);

dispatch_async(queue, ^() {
    dispatch_semaphor_wait(semaphor);
    //Todo...

    //Finished.
    dispatch_semaphor_signal(semaphor);
});
</code></pre>

<p>创建一个只允许一个线程访问的信号量 <code>disaptch_semaphor_create(1);</code></p>

<p>通知其他访问对象等待 <code>dispatch_semaphor_wait(semaphor);</code></p>

<p>资源访问结束后，退回占用的资源，并通知其他访问对象可以进行访问。 <code>dispatch_semaphor_signal(semaphor);</code></p></li>
<li><p>dispatch_group_wait</p>

<pre><code>dispatch_group_t group = dispatch_group_create();

dispatch_group_async(group, q1, ^ {
    //Task 1.
});

dispatch_group_async(group, q1, ^ {
    //Task 2.
});

dispatch_group_async(group, q1, ^ {
    //Task 3.
});

dispatch_async(queue, ^() {
    dispatch_group_wait(group);
    //Todo....

});
</code></pre>

<p><code>dispatch_group_async</code>: 添加任务到分组中。</p>

<p><code>dispatch_group_wait(group);</code> 等待 group 里的所有任务完成后方可继续。</p></li>
<li><p>dispatch_group_notify</p>

<pre><code>dispatch_group_notify(group, q1, ^ {
    //Todo...

});
</code></pre>

<p><code>dispatch_group_notify</code>: group中的所有任务完成后，执行 block 中的代码。</p></li>
<li><p>dispatch_group_enter, dispatch_group_leave</p>

<pre><code>dispatch_group_enter(group);

dispatch_async(q1, ^ {
    //Todo...

    dispatch_group_leave(group);
});
</code></pre>

<p>该代码等价于:</p>

<pre><code>dispatch_group_async(q1, ^ {
    //Todo...
});
</code></pre>

<p>作用也是将任务放入到 q1 队列中，同时也添加到分组中。</p></li>
</ol>


<h3>使用 apply 来提高并行效率</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>dispatch_apply(5000, q1, ^(size_t i) {
</span><span class='line'>    NSLog(@"%zu",  i);
</span><span class='line'>});</span></code></pre></td></tr></table></div></figure>


<p>你会发现如果 q1 是并发队列，输出的数字是无序的状态。这就是 dispatch_apply 带来的好处，它能快速将当前的迭代任务立刻发送到队列中执行，如果是并发队列，这个效率是很高的。如果你对任务的顺序有要求，或者队列是串行队列，那就不需要使用 dispatch_apply 了。</p>

<h3>dispatch_barrier_async</h3>

<p>障碍异步，意思是通过 dispatch_barrier_async 提交的任务，不会立刻执行，而是会阻碍它之后提交的任务，直到它之前的任务全部完成，它才会执行，并且它执行完毕后，其后提交的任务才能继续进行。</p>

<p>而在 dispatch_barrier_async 之前或者之后的任务都是并发执行的。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>dispatch_queue_t q = dispatch_queue_create("test", DISPATCH_QUEUE_CONCURRENT);
</span><span class='line'>
</span><span class='line'>dispatch_async(q, ^() {printf("A\n");});
</span><span class='line'>dispatch_async(q, ^() {printf("B\n");});
</span><span class='line'>dispatch_async(q, ^() {printf("C\n");});
</span><span class='line'>dispatch_async(q, ^() {printf("D\n");});
</span><span class='line'>
</span><span class='line'>dispatch_barrier_async(q, ^() {printf("barrier\n");});
</span><span class='line'>
</span><span class='line'>dispatch_async(q, ^() {printf("E\n");});
</span><span class='line'>dispatch_async(q, ^() {printf("F\n");});
</span><span class='line'>dispatch_async(q, ^() {printf("G\n");});
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure>


<p>输出结果是:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>A --
</span><span class='line'>C  |  
</span><span class='line'>D  |--&gt; //顺序随机产生
</span><span class='line'>B _|
</span><span class='line'>barrier //这里的输出位置不会变化
</span><span class='line'>F --
</span><span class='line'>E  |--&gt; //顺序随机产生
</span><span class='line'>G --
</span></code></pre></td></tr></table></div></figure>


<p>但是 dispatch_barrier_async 只有提交到自己创建的并发队列时，才有上面的效果。如果是全局队列，或者串行队列，那么 dispatch_barrier_async 和 dispatch_async 是等效的。</p>
</div> -->

  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title" ><a href="/blog/2015/08/23/xian-cheng-he-jin-cheng-jian-de-qu-bie/">线程和进程间的区别</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-08-23T15:13:25+08:00'><span class='date'><span class='date-month'>Aug</span> <span class='date-day'>23</span><span class='date-suffix'>rd</span>, <span class='date-year'>2015</span></span> <span class='time'>3:13 pm</span></time>
        
      </p>
    
  </header>



<!-- <div class="entry-content"><p><a href="http://www.programmerinterview.com/index.php/operating-systems/thread-vs-process/">译自</a></p>
</div> -->

  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title" ><a href="/blog/2015/08/23/timer-hui-diao-shi-jian-bei-uijiao-hu-zu-sai-de-jie-jue-ban-fa/">Timer ⌚回调事件被UI交互阻塞的解决办法</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-08-23T14:59:03+08:00'><span class='date'><span class='date-month'>Aug</span> <span class='date-day'>23</span><span class='date-suffix'>rd</span>, <span class='date-year'>2015</span></span> <span class='time'>2:59 pm</span></time>
        
      </p>
    
  </header>



<!-- <div class="entry-content"><p>分析原因：</p>

<p>UI 事件运行在主线程，并且UI 事件的运行模式下 runloop 过滤掉了 timer 事件。</p>

<p>回顾一下 runloop 的运行机制我们知道，runloop 是一个处理事件的循环，为了提高效率和隔离事件，它将事件进行了模式划分，通过 Runloop mode 的方式进行分类，并提供了 <code>runMode:beforeDate:</code> 方法 或者 <code>CFRunLoopRunInMode(CFStringRef mode, CFTimeInterval seconds, Boolean returnAfterSourceHandled)</code> 函数。所以 runloop 在 UI 事件进行中，始终运行在 NSRunLoopCommonModes 模式下。</p>

<h3>Runloop 的模式有这几种：</h3>

<p><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html" target="_blank">Runloop modes</a>></p>

<h4>Default: NSDefaultRunLoopMode(Cocoa), kCFRunLoopDefaultMode(Core Foundation)</h4>

<blockquote><p>The default mode is the one used for most operations. Most of the time, you should use this mode to start your run loop and configure your input sources.</p></blockquote>

<h4>Connection: NSConnectionReplyMode (Cocoa)</h4>

<blockquote><p>Cocoa uses this mode in conjunction with NSConnection objects to monitor replies. You should rarely need to use this mode yourself.</p></blockquote>

<h4>Modal: NSModalPanelRunLoopMode (Cocoa)</h4>

<blockquote><p>Cocoa uses this mode to identify events intended for modal panels.</p></blockquote>

<h4>Event tracking: NSEventTrackingRunLoopMode (Cocoa)</h4>

<blockquote><p>Cocoa uses this mode to restrict incoming events during mouse-dragging loops and other sorts of user interface tracking loops.</p></blockquote>

<h4>Common modes: NSRunLoopCommonModes (Cocoa), kCFRunLoopCommonModes (Core Foundation)</h4>

<blockquote><p>This is a configurable group of commonly used modes. Associating an input source with this mode also associates it with each of the modes in the group. For Cocoa applications, this set includes the default, modal, and event tracking modes by default. Core Foundation includes just the default mode initially. You can add custom modes to the set using the CFRunLoopAddCommonMode function.</p></blockquote>

<h3>解决方案有以下两种：</h3>

<h4>1. 在其他线程上运行 timer，并在需要的时候将操作发送到主线程</h4>

<p>objc:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)startTimer
</span><span class='line'>{
</span><span class='line'>    NSThread *th = [[NSThread alloc] initWithTarget:self selector:@selector(threadRun) object:nil];
</span><span class='line'>    [th start];
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>- (void)addInfinitTimerToCurrentRunloopWithTarget:(id)target selector:(SEL)selector inMode:(NSString *)mode
</span><span class='line'>{
</span><span class='line'>    NSTimer *timer = [NSTimer timerWithTimeInterval:1.0 target:self selector:@selector(timerRun:) userInfo:nil repeats:YES];
</span><span class='line'>    [[NSRunLoop currentRunLoop] addTimer:timer forMode:mode];
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>- (void)threadRun
</span><span class='line'>{
</span><span class='line'>    [self addInfinitTimerToCurrentRunloopWithTarget:self selector:@selector(timerRun:) inMode:@"MyTimerMode"];
</span><span class='line'>
</span><span class='line'>    while (YES) {
</span><span class='line'>        NSLog(@"%s while..", __FUNCTION__);
</span><span class='line'>        
</span><span class='line'>        [[NSRunLoop currentRunLoop] runMode:@"MyTimerMode" beforeDate:[NSDate distantFuture]];
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>- (void)timerRun:(id)sender
</span><span class='line'>{
</span><span class='line'>    NSLog(@"~");
</span><span class='line'>    [self performSelectorOnMainThread:@selector(someSelector) withObject:nil waitUntilDone:YES];
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>- (void)someSelector
</span><span class='line'>{
</span><span class='line'>  //....
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<p>这里用 NSThread 和自定义的计时器模式 <code>@"MyTimerMode"</code> 来实现。</p>

<h4>2.在主线程加入计时器</h4>

<p>objc:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)addInfinitTimerToCurrentRunloopWithTarget:(id)target selector:(SEL)selector inMode:(NSString *)mode
</span><span class='line'>{
</span><span class='line'>    NSTimer *timer = [NSTimer timerWithTimeInterval:1.0 target:self selector:@selector(timerRun:) userInfo:nil repeats:YES];
</span><span class='line'>    [[NSRunLoop currentRunLoop] addTimer:timer forMode:mode];
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>//运行在主线程上
</span><span class='line'>
</span><span class='line'>[self addInfinitTimerToCurrentRunloopWithTarget:self selector:@selector(timerRun:) inMode:NSRunLoopCommonModes];
</span></code></pre></td></tr></table></div></figure>


<p>让 timer 所运行的 Runloop mode 和UI 滚动事件的 Runloop mode 一致即可。</p>
</div> -->

  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/posts/2">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2015/08/28/kvo-ji-zhi/">KVO 机制</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/08/28/kvc-ji-zhi/">KVC 机制</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/08/27/use-dispatch-source-timer/">Use Dispatch Source Timer</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/08/23/bash-shi-yong-ji-qiao/">Bash 使用技巧</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/08/23/gcd-de-chang-gui-yong-fa/">GCD 的常规用法</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/08/23/xian-cheng-he-jin-cheng-jian-de-qu-bie/">线程和进程间的区别</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/08/23/timer-hui-diao-shi-jian-bei-uijiao-hu-zu-sai-de-jie-jue-ban-fa/">Timer ⌚回调事件被UI交互阻塞的解决办法</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/08/23/tong-guo-clang-fen-xi-block-de-ji-zhi/">通过 Clang 分析 Block 的机制</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/08/22/guan-li-zi-you-qiao-jie-toll-free-bridging/">管理自由桥接(Toll-Free Bridging)</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/08/21/arc-nei-cun-guan-li/">ARC 内存管理</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/08/21/jin-cheng-jian-tong-xin-fang-shi/">进程间通信方式</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/08/21/gitchang-jian-yong-fa/">Git常见用法</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/08/19/nsmutablecopying-and-nscopying/">NSMutableCopying and NSCopying</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/08/19/jekyll-site-class-available-attr/">Jekyll Site Class Available Attr</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/08/19/jekyll-configuration-fileds/">Jekyll Configuration Fileds</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/08/19/blockzai-clangzhong-de-shi-xian/">Block在Clang中的实现</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/08/18/autoreleasefang-fa-deyuan-ma-fen-xi/">Autorelease方法的源码分析</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/08/18/libdispatch-yuan-ma-fen-xi/">Libdispatch 源码分析</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/08/17/apple-source-code-&-documents/">Apple Source Code & Documents</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/08/16/shi-yong-xian-dai-objective-c/">使用现代Objective-C</a>
      </li>
    
  </ul>
</section>

<section>
  <h1>About Me</h1>
  <p>I'm focusing on iOS techs, and interested in web technologies.</p>
  <p><a href="mailto:dehengxu@outlook.com?subject=咱们认识一下吧">dehengxu@outlook.com</a></p>
  <p>QQ:36764672</p>
</section>

  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2015 - Deheng Xu -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
  <span class="credit"><a href="https://github.com/xudeheng" target="_blank">@github</a></span>
	<span class="credit"><a href="https://twitter.com/dehengxu" target="_blank">@twitter</a></span>
	<span class="credit"><a href="https://github.com/xudeheng/ios_tech_octopress" target="_blank">source</a></span>
  <span class="credit"><a href="http://www.dehengxu.com/" target="_blank">MyBase</a></span>
  <span class="credit"><a href="http://jekyllrb.com/docs/">JekyllDocs</a></span>
</p>

</footer>
  











</body>
</html>
