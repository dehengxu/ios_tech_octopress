<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[逆风@[iOS,nil]]]></title>
  <link href="http://ios.dehengxu.com/atom.xml" rel="self"/>
  <link href="http://ios.dehengxu.com/"/>
  <updated>2015-08-31T22:40:33+08:00</updated>
  <id>http://ios.dehengxu.com/</id>
  <author>
    <name><![CDATA[Deheng Xu]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Create a Private Pods]]></title>
    <link href="http://ios.dehengxu.com/blog/create-a-private-pods/"/>
    <updated>2015-08-31T22:20:30+08:00</updated>
    <id>http://ios.dehengxu.com/blog/create-a-private-pods</id>
    <content type="html"><![CDATA[<h3>1. 创建私有 Spec 仓库</h3>

<p>没必要 fork CocoaPods 的Spec 主仓库。你可以建立自己的仓库，也不用公开。</p>

<p>而且你也可以创建自己的私有本地仓库</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>cd /opt/git
</span><span class='line'>mkdir Specs.git
</span><span class='line'>cd Specs.git
</span><span class='line'>git init --bare</span></code></pre></td></tr></table></div></figure>


<h3>2. 添加私有仓库到 CocoaPods 安装文件中</h3>

<p><code>pod repo add REPO_NAME SOURCE_URL</code></p>

<blockquote><p>如果你想检测是否安装成功，可以这样测试：</p></blockquote>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>cd ~/.cocoapods/repos/REPO_NAME
</span><span class='line'>pod repo lint</span></code></pre></td></tr></table></div></figure>


<h3>3. 添加你的 podspec 到你自己的仓库</h3>

<p>pod repo push REPO_NAME SPEC_NAME.podspec</p>

<hr />

<p>最后，你需要在 podfile 文件中通过 <code>source</code> 指令来使用你自己的仓库：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>source 'YOUR_REPO_URL'</span></code></pre></td></tr></table></div></figure>


<p><a href="https://guides.cocoapods.org/making/private-cocoapods.html">REF</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Use Cocoapods Publish Your Podspec]]></title>
    <link href="http://ios.dehengxu.com/blog/use-cocoapods-publish-your-podspec/"/>
    <updated>2015-08-31T22:10:34+08:00</updated>
    <id>http://ios.dehengxu.com/blog/use-cocoapods-publish-your-podspec</id>
    <content type="html"><![CDATA[<h3>创建 podspec</h3>

<p>pod spec create NAME</p>

<h3>补完 podspec 文件</h3>

<p>参考例子：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='Ruby'><span class='line'><span class="no">Pod</span><span class="o">::</span><span class="no">Spec</span><span class="o">.</span><span class="n">new</span> <span class="k">do</span> <span class="o">|</span><span class="n">spec</span><span class="o">|</span>
</span><span class='line'>  <span class="n">spec</span><span class="o">.</span><span class="n">name</span>             <span class="o">=</span> <span class="s1">&#39;Reachability&#39;</span>
</span><span class='line'>  <span class="n">spec</span><span class="o">.</span><span class="n">version</span>          <span class="o">=</span> <span class="s1">&#39;3.1.0&#39;</span>
</span><span class='line'>  <span class="n">spec</span><span class="o">.</span><span class="n">license</span>          <span class="o">=</span> <span class="p">{</span> <span class="ss">:type</span> <span class="o">=&gt;</span> <span class="s1">&#39;BSD&#39;</span> <span class="p">}</span>
</span><span class='line'>  <span class="n">spec</span><span class="o">.</span><span class="n">homepage</span>         <span class="o">=</span> <span class="s1">&#39;https://github.com/tonymillion/Reachability&#39;</span>
</span><span class='line'>  <span class="n">spec</span><span class="o">.</span><span class="n">authors</span>          <span class="o">=</span> <span class="p">{</span> <span class="s1">&#39;Tony Million&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;tonymillion@gmail.com&#39;</span> <span class="p">}</span>
</span><span class='line'>  <span class="n">spec</span><span class="o">.</span><span class="n">summary</span>          <span class="o">=</span> <span class="s1">&#39;ARC and GCD Compatible Reachability Class for iOS and OS X.&#39;</span>
</span><span class='line'>  <span class="n">spec</span><span class="o">.</span><span class="n">source</span>           <span class="o">=</span> <span class="p">{</span> <span class="ss">:git</span> <span class="o">=&gt;</span> <span class="s1">&#39;https://github.com/tonymillion/Reachability.git&#39;</span><span class="p">,</span> <span class="ss">:tag</span> <span class="o">=&gt;</span> <span class="s1">&#39;v3.1.0&#39;</span> <span class="p">}</span>
</span><span class='line'>  <span class="n">spec</span><span class="o">.</span><span class="n">source_files</span>     <span class="o">=</span> <span class="s1">&#39;Reachability.h,m&#39;</span>
</span><span class='line'>  <span class="n">spec</span><span class="o">.</span><span class="n">framework</span>        <span class="o">=</span> <span class="s1">&#39;SystemConfiguration&#39;</span>
</span><span class='line'>  <span class="n">spec</span><span class="o">.</span><span class="n">requires_arc</span>     <span class="o">=</span> <span class="kp">true</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p><a href="https://guides.cocoapods.org/making/specs-and-specs-repo.html">Offical Docs</a></p>

<h3>验证代码</h3>

<p><code>pod lib lint CoreDataEnvir.podspec</code></p>

<h3>验证 podspec</h3>

<p><code>pod spec lint CoreDataEnvir.podspec</code></p>

<h3>注册 Cocoapods 会话</h3>

<p>为了保证与 Cocoapods 通信的合法性，需要在你的电脑上注册一个会话，方法如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='Bash'><span class='line'>pod trunk register orta@cocoapods.org <span class="s1">&#39;Orta Therox&#39;</span> --description<span class="o">=</span><span class="s1">&#39;macbook air&#39;</span>
</span></code></pre></td></tr></table></div></figure>


<p>执行完后，你的邮箱会收到一封激活邮件，点击其中的激活链接后，你的会话就算是合法了。</p>

<h3>提交你的 podspec</h3>

<p><code>pod trunk push CoreDataEnvir.podspec</code> 这条命令会把你的 podspec 提交到公共库中。</p>

<p>如果需要提交到私有库，你需要执行 <code>pod trunk push REPO CoreDataEnvir.podspec</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Runtime 在新版本 Xcode 中引起的编译错误，及解决方法]]></title>
    <link href="http://ios.dehengxu.com/blog/objc-msgsend-bian-yi-cuo-wu-de-jie-jue-fang-fa/"/>
    <updated>2015-08-30T12:13:22+08:00</updated>
    <id>http://ios.dehengxu.com/blog/objc-msgsend-bian-yi-cuo-wu-de-jie-jue-fang-fa</id>
    <content type="html"><![CDATA[<h2>objc_msgSend</h2>

<p>最近在 Xcode6.4 上编译一个老旧的库时，出现了运行时函数 <code>objc_msgSend</code> 的编译错误，提示:</p>

<p><code>Too many arguments to function call, excepted 0, have 7</code>，说函数不需要参数，却传入了7个参数。</p>

<p>原来是预编译指令的问题:</p>

<p>找到编译出错的那个库，选中 target -> Build Settings 搜索框中输入 <code>objc</code></p>

<p>定位到这里:</p>

<p><img src="http://ios.dehengxu.com/images/refered/runtime_msgsend_fix.png" alt="msgSend_fix" /></p>

<p>将 <code>Enable Strict Checking of objc_msgSend Calls</code>  字段设为 <code>NO</code></p>

<p>关闭 <code>objc_msgSend</code> 的严格调用检查。</p>

<h2>object->isa</h2>

<p>最近在 Xcode6.4 上编译依赖 JSONKit 的时候，对于 JSONKit 内部通过指针访问 <code>isa</code> 变量代码，引起编译错误，提示:</p>

<p><code>Assignment to Objective-C's isa is deprecated in favor of object_setClass()</code> 或者 <code>Assignment to Objective-C's isa is deprecated in favor of object_getClass()</code></p>

<p>如图:</p>

<p><img src="http://ios.dehengxu.com/images/refered/runtime_isa_error.png" alt="isa_err" /></p>

<p>解决办法：找到 JSONKit 项目 target -> Build Settings 搜索框中输入 <code>isa</code></p>

<p>定位到:</p>

<p><img src="http://ios.dehengxu.com/images/refered/runtime_isa_fix.png" alt="isa_err" /></p>

<p>修改为 <code>NO</code> 即可。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[自定义类如何提供 KVC 兼容特性]]></title>
    <link href="http://ios.dehengxu.com/blog/zi-ding-yi-lei-ru-he-ti-gong-kvc-jian-rong-te-xing/"/>
    <updated>2015-08-29T15:10:33+08:00</updated>
    <id>http://ios.dehengxu.com/blog/zi-ding-yi-lei-ru-he-ti-gong-kvc-jian-rong-te-xing</id>
    <content type="html"><![CDATA[<h3>KVC 兼容性</h3>

<h4>对一的关系</h4>

<p>对于属性来说，附属值会存在一对一的关系，这就需要你的类拥有一下特征：</p>

<ul>
<li><p>实现 <code>-key</code>, <code>-is&lt;Key&gt;</code> 方法类，或者存在有一个叫 <code>key</code> 或者 <code>_key</code> 的实例对象。(显然，这是 getter 访问器的规则)。虽然 key 名字常常以小写字母开头，KVC 也支持 key名称以大写字母开头，例如：<code>URL</code>。</p></li>
<li><p>如果该属性是可以修改的，那么就应该实现 <code>-set&lt;Key&gt;:</code> 方法。PS:框架会自动寻找 <code>key</code> 或者 <code>_key</code>形式的变量来完成对应操作。</p></li>
<li><p>你的 <code>-set&lt;Key&gt;:</code> 实现方法不应该执行验证操作。</p></li>
<li><p>如果你需要验证 <code>key</code> 的话，你需要实现 <code>-validate&lt;key&gt;:error:</code> 的方法。</p></li>
</ul>


<h4>索引化的对多关系</h4>

<p>对于索引化的对多关系而言，KVC 兼容性需要你的类拥有这些特征：</p>

<ul>
<li><p>实现名为 <code>-&lt;key&gt;</code> 并返回数组的方法。</p></li>
<li><p>或者拥有一个名为 <code>key</code> 或 <code>_key</code> 的数组实例对象变量。</p></li>
<li><p>或者实现 <code>-countOf&lt;key&gt;</code> 方法，并且实现 <code>-objectIn&lt;key&gt;AtIndex:</code> 和 <code>-&lt;key&gt;AtIndexes:</code> 两个方法中的一个或所有方法。</p></li>
<li><p>你也能可选的实现 <code>-get&lt;key&gt;:range:</code> 方法来提高性能表现。</p></li>
</ul>


<p>对于可修改的索引化有序对多关系，KVC 兼容性也需要你的类提供这些特征：</p>

<ul>
<li><p>实现 <code>-insertObject:in&lt;key&gt;AtIndex:</code> 和 <code>-insert&lt;Key&gt;:atIndexex:</code> 中的一个或所有方法。</p></li>
<li><p>当然如果愿意，你可也可以实现 <code>-replaceObjectIn&lt;key&gt;AtIndex:withObject:</code> 或 <code>-replace&lt;key&gt;AtIndexes:with&lt;key&gt;:</code> 来提高性能表现。这仅仅是个可选项。 :)</p></li>
</ul>


<h4>无序的对多关系兼容性</h4>

<p>对于无序的对多关系来说，KVC 兼容性需要你的类提供这些特征：</p>

<ul>
<li><p>实现能返回集合的名为 <code>-&lt;key&gt;</code> 的方法。</p></li>
<li><p>或者包含一个名为 <code>key</code> 或 <code>_key</code> 的实例变量。</p></li>
<li><p>或者实现 <code>-countOf&lt;key&gt;</code>，<code>-enumeratorOf&lt;key&gt;</code> 和 <code>-memberOf&lt;key&gt;:</code> 方法。</p></li>
</ul>


<p>对于可变的无序对多关系而言，KVC 兼容性需要你的类也提供这些：</p>

<ul>
<li><p>实现方法 <code>-add&lt;key&gt;Object:</code> 或 <code>-add&lt;key&gt;:</code> 中的一个或所有。</p></li>
<li><p>实现方法 <code>-remove&lt;key&gt;Object:</code> 或 <code>-remove&lt;key&gt;:</code>中的一个或所有。</p></li>
<li><p>你也可以实现 <code>-intersect&lt;key&gt;:</code> 和 <code>-set&lt;key&gt;:</code> 来提高性能表现，不过这是个可选项，根据你面临的情况自己选择吧。</p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用 NSValue 封装任意结构体]]></title>
    <link href="http://ios.dehengxu.com/blog/shi-yong-nsvalue-feng-zhuang-ren-yi-jie-gou-ti/"/>
    <updated>2015-08-29T12:55:21+08:00</updated>
    <id>http://ios.dehengxu.com/blog/shi-yong-nsvalue-feng-zhuang-ren-yi-jie-gou-ti</id>
    <content type="html"><![CDATA[<h2>NSValue</h2>

<p>装包，拆包，分别用到 <code>value:withObjCType:</code> 和 <code>getValue:</code>两个方法。</p>

<p>第一个是通过 type 类型，将 value 封装成 NSValue 对象。</p>

<p>后者是通过 NSValue 对象，获取值型数据</p>

<p>假设有一个自定义结构体</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct Node {
</span><span class='line'>    struct Node *next;
</span><span class='line'>    char *name;
</span><span class='line'>    int age;
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct Node *header = (struct Node *)malloc(sizeof(struct Node));
</span><span class='line'>header-&gt;name = "Nicholasxu";
</span><span class='line'>header-&gt;age = 89;    
</span><span class='line'>NSValue *value = [NSValue value:header withObjCType:@encode(struct Node)];</span></code></pre></td></tr></table></div></figure>


<p>通过 <code>@encode</code> 将C 类型转换成 Objective-C 能识别的 char * 形式。</p>

<p>解包方法如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct Node *chain = (struct Node *)malloc(sizeof(struct Node));
</span><span class='line'>[value getValue:chain];
</span><span class='line'>NSLog(@"%s", chain-&gt;name);
</span><span class='line'>NSLog(@"%s", chain-&gt;age);
</span></code></pre></td></tr></table></div></figure>


<p>先分配结构题内存 <code>chain</code>，再将数据解包出来，并填充 <code>chain</code> 的空间。</p>

<h3>内存布局</h3>

<p>上面的例子中，<code>value</code> 和 header 都是在堆上分配的空间并且 header 的内存和 value 内部的数据是同一个内存空间，要做好 header 的内存管理工作，否则会导致 value 无法访问内部数据(出现野指针)。而且 chain 的数据是从 value 中复制过来的。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[KVO 机制]]></title>
    <link href="http://ios.dehengxu.com/blog/kvo-ji-zhi/"/>
    <updated>2015-08-28T18:36:18+08:00</updated>
    <id>http://ios.dehengxu.com/blog/kvo-ji-zhi</id>
    <content type="html"><![CDATA[<h2>KVO : 键值观察 (Key-value observing)</h2>

<p>KVO 是一个允许一个对象直接接受来自另一个对象属性改变时发送的通知的机制。KVO 能成为应用内部重要的因素。它是采用了MVC设计模式的应用程序中对象间的一种通信模式。比如，你可以使用它来同步 view 和 controller 层中模型对象之间的状态。典型情况下，控制器对象观察模型对象，试图对象观察控制器对象或者模型对象。</p>

<blockquote><p>注意：虽然 UIKit 框架通常不支持 KVO，你仍然能够在自定义的对象中实现它，包括自定义的视图。</p></blockquote>

<p><img src="http://ios.dehengxu.com/images/refered/kvo.jpg" alt="kvo" /></p>

<p>使用 KVO，一个对象可以观察另一个对象的任意的属性，包括简单的附属值，对一的关系和对多的关系。一个对象能找出当前属性先前的值。对多关系的观察者被通告的内容不仅有类型的改变，也被告知哪个对象在改变中被调用。</p>

<p>作为一个通知机制，KVO 和 <code>NSNotification</code> 和 <code>NSNotificationCenter</code> 提供的机制类似，但是也有一些明显的不同。不同于中央对象来对所有注册为观察者的对象广播通知，当属性值的改变发生时，KVO 通知直接发送给观察对象。</p>

<h3>实现 KVO</h3>

<p>根类 <code>NSObject</code>，提供了基本的 KVO 实现，你很少需要重载它。因此所有的 Cocoa objects 都继承了 KVO 的能力。你必须按照这些步骤来接收某个属性的 KVO 通知。</p>

<ul>
<li><p>你必须确保被观察的类对于你想观察的属性是符合 KVO 规范。 KVO 兼容性需要被观察对象的类也是 KVO 兼容的，而且也允许为该属性自动发送观察者通知，或者手动实现该属性的 KVO 。</p></li>
<li><p>添加一个观察者到一个值会发生改变的对象。你可以通过调用 <code>addObserver:forKeyPath:optios:context:</code> 来达到这个目的。观察者是应用中的另一个对象。</p></li>
<li><p>在观察者对象中，实现方法 <code>observeValueForKeyPath:ofObject:change:context:</code> 。当被观察对象的属性值发生改变的时候这个方法会被调用。</p></li>
</ul>


<h3>KVO 是绑定(OS X)的必须部分</h3>

<p>Cocoa 绑定是一个允许你不用写一些胶水代码就能确保模型中的值和你应用程序中的视图层同步的 OS X 技术。通过 Interface Builder 检查器中，你就能在视图属性和一些数据之间建立起协调链接，“绑定”他们就像其中一个发生改变会在其他身上反映出来。KVO，和 KVC 还有 KVB 都是 Cocoa 绑定的基础技术。</p>

<h3>后话</h3>

<p><img src="http://ios.dehengxu.com/images/refered/kvo_proj_snap1.png" alt="KVO runtime" /></p>

<p>从上图可以看出 KVO 是一个同步调用过程通过 _NSSetObjectValueAndNotify 函数，在设置对象值的同时向观察对象发送变化通知，同时会通过 <code>NSKeyValueObservingOptions</code> 类型来区分 KVO 发生的类型，并在 <code>- (void)observeValueForKeyPath:(nullable NSString *)keyPath ofObject:(nullable id)object change:(nullable NSDictionary *)change context:(nullable void *)context</code> 的 change 字典对象中传递相关值的变化信息(old value, new value 等)。</p>

<p>同时需要注意的是观察者是通过弱引用方式加入到被观察对象中的，所以当不需要继续观察的时候，请使用<code>removeObserver:forKeyPath:</code> 移除不再需要的观察者以免引起运行时异常。</p>

<h3>前提文章</h3>

<p><a href="https://developer.apple.com/library/ios/documentation/General/Conceptual/DevPedia-CocoaCore/KeyValueCoding.html#//apple_ref/doc/uid/TP40008195-CH25-SW1">Key-value coding</a></p>

<h3>相关的文章</h3>

<p><a href="https://developer.apple.com/library/ios/documentation/General/Conceptual/DevPedia-CocoaCore/MVC.html#//apple_ref/doc/uid/TP40008195-CH32-SW1">Model-View-Controller</a></p>

<p><a href="https://developer.apple.com/library/ios/documentation/General/Conceptual/DevPedia-CocoaCore/DynamicBinding.html#//apple_ref/doc/uid/TP40008195-CH15-SW1">Dynamic binding</a></p>

<h3>权威论述</h3>

<p><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/KeyValueObserving/KeyValueObserving.html#//apple_ref/doc/uid/10000177i">Key-value Observing Programming Guide</a></p>

<hr />

<p><a href="https://developer.apple.com/library/ios/documentation/General/Conceptual/DevPedia-CocoaCore/KVO.html#//apple_ref/doc/uid/TP40008195-CH16-SW1">Ref</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[KVC 机制]]></title>
    <link href="http://ios.dehengxu.com/blog/kvc-ji-zhi/"/>
    <updated>2015-08-28T17:16:18+08:00</updated>
    <id>http://ios.dehengxu.com/blog/kvc-ji-zhi</id>
    <content type="html"><![CDATA[<h2>KVC : 键值编码 (Key-value coding)</h2>

<p>键值编码是一个通过字符串间接访问对象属性和关系的机制。它是 Cocoa编程中一些机制和技术的基石，在他们中间 Core Data, 应用程序脚本能力, 绑定技术，还有语言特性中的属性声明。 (脚本特性和绑定是指 OS X 上的 Cocoa。) 你也能使用键值编码来简化你的程序代码。</p>

<h3>对象属性和 KVC</h3>

<p>KVC 的核心是属性的通用概念。一个属性对应一个对象封装的状态单元。属性可以是这两种类型中的一个：一个属性(例如：name, subtotal, 或者 textColor) 或者相对于其他对象的关系。关系既可以是 一对一，也可以是一对多。一对多关系的值通常是一个数组或者集合，取决于关系是否有序。</p>

<p>KVC 通过“键”来定位对象的属性，其实就是一个字符串标识。“键”常常代表一个访问器方法或者实例变量的名字。“键”必须符合某种规则：必须是 ASCII 编码，小写字母开头，还没有空格。Key path是由点与“键”分隔的字符串，它被用来指明一系列对象属性的链式访问。序列的第一个“键”是相对于指定的对象来说的(如下面图表中的 employee1)，并且每个子序列“键”是相对于前一个属性值来的。</p>

<p><img src="http://ios.dehengxu.com/images/refered/key_value_coding.jpg" alt="sample" /></p>

<h3>使类支持 KVC</h3>

<p>NSKeyValueCoding 非正式的协议使 KVC 成为可能。其中两个方法： <code>valueForKey:</code> 和 <code>setValue:forKey:</code> 是特殊且重要的方法，因为他们能获取，设置给定 “键” 的属性值。 <code>NSObject</code> 为这两个方法提供了默认实现，并且如果类和 KVC 兼容，它可以依赖这个实现。</p>

<p>你如何实现属性 KVC 的兼容性，依赖于属性是一个附属值，一对多或者一对一的关系。对于附属值，一对一关系来说，类必须至少实现一个以下给定顺序的配置(键 和属性的键关联)：</p>

<ol>
<li>类使用“键”的名字来声明属性</li>
<li>实现以“键”命名的访问器，如果属性是可修改的，需要实现<code>setKey:</code>(如果属性是一个布尔值，<code>getter</code>访问起方法有 <code>isKey</code> 有形式。)</li>
<li>声明 <code>key</code> 或者 <code>_key</code>形式的实例变量。</li>
</ol>


<blockquote><p>PS: 这里我认为 <code>attribute</code>叫做附属值或者值，<code>property</code>称作属性更恰当。一般来说 attrubute 比 property 要轻量级一些。</p></blockquote>

<p>实现对多的 KVC 兼容是一个更复杂的过程。可以参考权关于 KVC 威性的文档来学习实现的过程。</p>

<h3>后话</h3>

<p>KVC 规则就是通过 <code>setValue:forKey:</code> 对 key 所对应的变量或者属性进行赋值操作，举个简单的例子：</p>

<p>类 <code>People</code></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@interface People : NSObject
</span><span class='line'>{
</span><span class='line'>  NSString *_name;
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<p>这种情况下你可以通过 <code>[people setValue:@"Nick" forKey:@"name"]</code> 或者 <code>[people setValue:@"Nick" forKey:@"_name"]</code> 为 <code>_name</code> 变量赋值。 就是说 KVC 会为 <code>key</code> 或者 <code>_key</code> 为名称的变量完成操作。</p>

<p>将代码改为：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@interface People : NSObject
</span><span class='line'>{
</span><span class='line'>  NSString *name;
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<p>依然执行 <code>[people setValue:@"Nick" forKey:@"name"]</code> 或者 <code>[people setValue:@"Nick" forKey:@"_name"]</code> 方法，后者会提示错误 <code>this class is not key value coding-compliant for the key _name."</code></p>

<p>说明 KVC 的逻辑是为名为 <code>_&lt;name&gt;</code> 的变量通过 <code>_&lt;name&gt;</code> 或 <code>&lt;name&gt;</code> 形式的 key 来进行 KVC 操作。除此之外针对 <code>&lt;name&gt;</code> 的变量, 一律通过 <code>&lt;name&gt;</code> 形式的 key 来做 KVC 操作。</p>

<p><a href="http://ios.dehengxu.com/blog/zi-ding-yi-lei-ru-he-ti-gong-kvc-jian-rong-te-xing/">KVC 兼容特性</a></p>

<h3>前提文章</h3>

<p><a href="https://developer.apple.com/library/ios/documentation/General/Conceptual/DevPedia-CocoaCore/ObjectModeling.html#//apple_ref/doc/uid/TP40008195-CH41-SW1">Object modeling</a></p>

<p><a href="https://developer.apple.com/library/ios/documentation/General/Conceptual/DevPedia-CocoaCore/AccessorMethod.html#//apple_ref/doc/uid/TP40008195-CH2-SW1">Accessor method</a></p>

<h3>相关文章</h3>

<p><a href="https://developer.apple.com/library/ios/documentation/General/Conceptual/DevPedia-CocoaCore/DeclaredProperty.html#//apple_ref/doc/uid/TP40008195-CH13-SW1">Declared property</a></p>

<h3>权威论述</h3>

<p><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/KeyValueCoding/Articles/KeyValueCoding.html#//apple_ref/doc/uid/10000107i">Key-value Coding Programming Guide</a></p>

<hr />

<p><a href="https://developer.apple.com/library/ios/documentation/General/Conceptual/DevPedia-CocoaCore/KeyValueCoding.html#//apple_ref/doc/uid/TP40008195-CH25-SW1">Ref</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Use Dispatch Source Timer]]></title>
    <link href="http://ios.dehengxu.com/blog/use-dispatch-source-timer/"/>
    <updated>2015-08-27T16:58:03+08:00</updated>
    <id>http://ios.dehengxu.com/blog/use-dispatch-source-timer</id>
    <content type="html"><![CDATA[<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>dispatch_queue_t queue = dispatch_queue_create("com.xxx.timer", DISPATCH_QUEUE_CONCURRENT);
</span><span class='line'>
</span><span class='line'>dispatch_source_t timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue);
</span><span class='line'>
</span><span class='line'>dispatch_source_set_timer(timer, DISPATCH_TIME_NOW, 1 * NSEC_PER_SEC, NSEC_PER_SEC / 10);
</span><span class='line'>
</span><span class='line'>// 设置定时器回调 block
</span><span class='line'>dispatch_source_set_event_handler(timer, ^ {
</span><span class='line'>  //do something...
</span><span class='line'>});
</span><span class='line'>
</span><span class='line'>dispatch_resume(timer);
</span></code></pre></td></tr></table></div></figure>


<p>关键点： timer 一定要被 retain ，防止提前释放，否则 timer 无效。</p>

<p>关闭 timer 可以使用 <code>dispatch_source_cancel</code> 函数。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Bash 使用技巧]]></title>
    <link href="http://ios.dehengxu.com/blog/bash-shi-yong-ji-qiao/"/>
    <updated>2015-08-23T23:11:02+08:00</updated>
    <id>http://ios.dehengxu.com/blog/bash-shi-yong-ji-qiao</id>
    <content type="html"><![CDATA[<h4>递归搜索目录下所有文件内容</h4>

<p>bash</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>ls ./**/*.ext | xargs grep algorit</span></code></pre></td></tr></table></div></figure>


<blockquote><p>搜索当前目录下所有的 ext 文件，并且匹配是否包含关键词 <code>algorit</code></p></blockquote>

<h4>查找进程</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>es -ef|grep name</span></code></pre></td></tr></table></div></figure>


<blockquote><p>查找进程名包含 <code>name</code> 的进程</p></blockquote>

<h4>查看开启的端口</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>lsof -i:8080</span></code></pre></td></tr></table></div></figure>


<blockquote><p>查看使用端口 8080 的进程</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[GCD 的常规用法]]></title>
    <link href="http://ios.dehengxu.com/blog/gcd-de-chang-gui-yong-fa/"/>
    <updated>2015-08-23T15:56:50+08:00</updated>
    <id>http://ios.dehengxu.com/blog/gcd-de-chang-gui-yong-fa</id>
    <content type="html"><![CDATA[<p>GCD 通过将多线程抽象为 <code>dispatch_queue_t</code> 类型的对象，以 Block 作为计算单元实现的一套基于 C 语言的开源多线程库 <code>libdispatch</code>。</p>

<p>GCD 让多线程开发变的更加方便，简洁。</p>

<p>首先明确几个 GCD 中的特性:</p>

<ol>
<li>全局队列都是异步的。</li>
<li>主队列是同步的。</li>
<li>串行队列中在当前上下文执行同步计算会产生死锁。</li>
</ol>


<h3>创建并行，串行队列</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>dispatch_queue_create("q1", DISPATCH_QUEUE_CONCURRENT);</span></code></pre></td></tr></table></div></figure>




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>dispatch_queue_create("q1", DISPATCH_QUEUE_SERIAL);</span></code></pre></td></tr></table></div></figure>


<h3>异步执行任务</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>disaptch_async(queue, ^() {
</span><span class='line'>  //Todo....
</span><span class='line'>});</span></code></pre></td></tr></table></div></figure>


<h3>同步执行任务的方式</h3>

<ol>
<li><p>dispatch_semaphor_t</p>

<pre><code>dispatch_semaphor_t semaphor = disaptch_semaphor_create(1);

dispatch_async(queue, ^() {
    dispatch_semaphor_wait(semaphor);
    //Todo...

    //Finished.
    dispatch_semaphor_signal(semaphor);
});
</code></pre>

<p>创建一个只允许一个线程访问的信号量 <code>disaptch_semaphor_create(1);</code></p>

<p>通知其他访问对象等待 <code>dispatch_semaphor_wait(semaphor);</code></p>

<p>资源访问结束后，退回占用的资源，并通知其他访问对象可以进行访问。 <code>dispatch_semaphor_signal(semaphor);</code></p></li>
<li><p>dispatch_group_wait</p>

<pre><code>dispatch_group_t group = dispatch_group_create();

dispatch_group_async(group, q1, ^ {
    //Task 1.
});

dispatch_group_async(group, q1, ^ {
    //Task 2.
});

dispatch_group_async(group, q1, ^ {
    //Task 3.
});

dispatch_async(queue, ^() {
    dispatch_group_wait(group);
    //Todo....

});
</code></pre>

<p><code>dispatch_group_async</code>: 添加任务到分组中。</p>

<p><code>dispatch_group_wait(group);</code> 等待 group 里的所有任务完成后方可继续。</p></li>
<li><p>dispatch_group_notify</p>

<pre><code>dispatch_group_notify(group, q1, ^ {
    //Todo...

});
</code></pre>

<p><code>dispatch_group_notify</code>: group中的所有任务完成后，执行 block 中的代码。</p></li>
<li><p>dispatch_group_enter, dispatch_group_leave</p>

<pre><code>dispatch_group_enter(group);

dispatch_async(q1, ^ {
    //Todo...

    dispatch_group_leave(group);
});
</code></pre>

<p>该代码等价于:</p>

<pre><code>dispatch_group_async(q1, ^ {
    //Todo...
});
</code></pre>

<p>作用也是将任务放入到 q1 队列中，同时也添加到分组中。</p></li>
</ol>


<h3>使用 apply 来提高并行效率</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>dispatch_apply(5000, q1, ^(size_t i) {
</span><span class='line'>    NSLog(@"%zu",  i);
</span><span class='line'>});</span></code></pre></td></tr></table></div></figure>


<p>你会发现如果 q1 是并发队列，输出的数字是无序的状态。这就是 dispatch_apply 带来的好处，它能快速将当前的迭代任务立刻发送到队列中执行，如果是并发队列，这个效率是很高的。如果你对任务的顺序有要求，或者队列是串行队列，那就不需要使用 dispatch_apply 了。</p>

<h3>dispatch_barrier_async</h3>

<p>阻碍异步，意思是通过 dispatch_barrier_async 提交的任务，不会立刻执行，而是会阻碍它之后提交的任务，直到它之前的任务全部完成，它才会执行，并且它执行完毕后，其后提交的任务才能继续进行。</p>

<p>而在 dispatch_barrier_async 之前或者之后的任务都是并发执行的。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>dispatch_queue_t q = dispatch_queue_create("test", DISPATCH_QUEUE_CONCURRENT);
</span><span class='line'>
</span><span class='line'>dispatch_async(q, ^() {printf("A\n");});
</span><span class='line'>dispatch_async(q, ^() {printf("B\n");});
</span><span class='line'>dispatch_async(q, ^() {printf("C\n");});
</span><span class='line'>dispatch_async(q, ^() {printf("D\n");});
</span><span class='line'>
</span><span class='line'>dispatch_barrier_async(q, ^() {printf("barrier\n");});
</span><span class='line'>
</span><span class='line'>dispatch_async(q, ^() {printf("E\n");});
</span><span class='line'>dispatch_async(q, ^() {printf("F\n");});
</span><span class='line'>dispatch_async(q, ^() {printf("G\n");});
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure>


<p>输出结果是:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>A --
</span><span class='line'>C  |  
</span><span class='line'>D  |--&gt; //顺序随机产生
</span><span class='line'>B _|
</span><span class='line'>barrier //这里的输出位置不会变化
</span><span class='line'>F --
</span><span class='line'>E  |--&gt; //顺序随机产生
</span><span class='line'>G --
</span></code></pre></td></tr></table></div></figure>


<p>但是 dispatch_barrier_async 只有提交到自己创建的并发队列时，才有上面的效果。如果是全局队列，或者串行队列，那么 dispatch_barrier_async 和 dispatch_async 是等效的。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[线程和进程间的区别]]></title>
    <link href="http://ios.dehengxu.com/blog/xian-cheng-he-jin-cheng-jian-de-qu-bie/"/>
    <updated>2015-08-23T15:13:25+08:00</updated>
    <id>http://ios.dehengxu.com/blog/xian-cheng-he-jin-cheng-jian-de-qu-bie</id>
    <content type="html"><![CDATA[<p><a href="http://www.programmerinterview.com/index.php/operating-systems/thread-vs-process/">译自</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Timer ⌚回调事件被UI交互阻塞的解决办法]]></title>
    <link href="http://ios.dehengxu.com/blog/timer-hui-diao-shi-jian-bei-uijiao-hu-zu-sai-de-jie-jue-ban-fa/"/>
    <updated>2015-08-23T14:59:03+08:00</updated>
    <id>http://ios.dehengxu.com/blog/timer-hui-diao-shi-jian-bei-uijiao-hu-zu-sai-de-jie-jue-ban-fa</id>
    <content type="html"><![CDATA[<p>分析原因：</p>

<p>UI 事件运行在主线程，并且UI 事件的运行模式下 runloop 过滤掉了 timer 事件。</p>

<p>回顾一下 runloop 的运行机制我们知道，runloop 是一个处理事件的循环，为了提高效率和隔离事件，它将事件进行了模式划分，通过 Runloop mode 的方式进行分类，并提供了 <code>runMode:beforeDate:</code> 方法 或者 <code>CFRunLoopRunInMode(CFStringRef mode, CFTimeInterval seconds, Boolean returnAfterSourceHandled)</code> 函数。所以 runloop 在 UI 事件进行中，始终运行在 NSRunLoopCommonModes 模式下。</p>

<h3>Runloop 的模式有这几种：</h3>

<p><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html" target="_blank">Runloop modes</a>></p>

<h4>Default: NSDefaultRunLoopMode(Cocoa), kCFRunLoopDefaultMode(Core Foundation)</h4>

<blockquote><p>The default mode is the one used for most operations. Most of the time, you should use this mode to start your run loop and configure your input sources.</p></blockquote>

<h4>Connection: NSConnectionReplyMode (Cocoa)</h4>

<blockquote><p>Cocoa uses this mode in conjunction with NSConnection objects to monitor replies. You should rarely need to use this mode yourself.</p></blockquote>

<h4>Modal: NSModalPanelRunLoopMode (Cocoa)</h4>

<blockquote><p>Cocoa uses this mode to identify events intended for modal panels.</p></blockquote>

<h4>Event tracking: NSEventTrackingRunLoopMode (Cocoa)</h4>

<blockquote><p>Cocoa uses this mode to restrict incoming events during mouse-dragging loops and other sorts of user interface tracking loops.</p></blockquote>

<h4>Common modes: NSRunLoopCommonModes (Cocoa), kCFRunLoopCommonModes (Core Foundation)</h4>

<blockquote><p>This is a configurable group of commonly used modes. Associating an input source with this mode also associates it with each of the modes in the group. For Cocoa applications, this set includes the default, modal, and event tracking modes by default. Core Foundation includes just the default mode initially. You can add custom modes to the set using the CFRunLoopAddCommonMode function.</p></blockquote>

<h3>解决方案有以下两种：</h3>

<h4>1. 在其他线程上运行 timer，并在需要的时候将操作发送到主线程</h4>

<p>objc:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)startTimer
</span><span class='line'>{
</span><span class='line'>    NSThread *th = [[NSThread alloc] initWithTarget:self selector:@selector(threadRun) object:nil];
</span><span class='line'>    [th start];
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>- (void)addInfinitTimerToCurrentRunloopWithTarget:(id)target selector:(SEL)selector inMode:(NSString *)mode
</span><span class='line'>{
</span><span class='line'>    NSTimer *timer = [NSTimer timerWithTimeInterval:1.0 target:self selector:@selector(timerRun:) userInfo:nil repeats:YES];
</span><span class='line'>    [[NSRunLoop currentRunLoop] addTimer:timer forMode:mode];
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>- (void)threadRun
</span><span class='line'>{
</span><span class='line'>    [self addInfinitTimerToCurrentRunloopWithTarget:self selector:@selector(timerRun:) inMode:@"MyTimerMode"];
</span><span class='line'>
</span><span class='line'>    while (YES) {
</span><span class='line'>        NSLog(@"%s while..", __FUNCTION__);
</span><span class='line'>        
</span><span class='line'>        [[NSRunLoop currentRunLoop] runMode:@"MyTimerMode" beforeDate:[NSDate distantFuture]];
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>- (void)timerRun:(id)sender
</span><span class='line'>{
</span><span class='line'>    NSLog(@"~");
</span><span class='line'>    [self performSelectorOnMainThread:@selector(someSelector) withObject:nil waitUntilDone:YES];
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>- (void)someSelector
</span><span class='line'>{
</span><span class='line'>  //....
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<p>这里用 NSThread 和自定义的计时器模式 <code>@"MyTimerMode"</code> 来实现。</p>

<h4>2.在主线程加入计时器</h4>

<p>objc:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)addInfinitTimerToCurrentRunloopWithTarget:(id)target selector:(SEL)selector inMode:(NSString *)mode
</span><span class='line'>{
</span><span class='line'>    NSTimer *timer = [NSTimer timerWithTimeInterval:1.0 target:self selector:@selector(timerRun:) userInfo:nil repeats:YES];
</span><span class='line'>    [[NSRunLoop currentRunLoop] addTimer:timer forMode:mode];
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>//运行在主线程上
</span><span class='line'>
</span><span class='line'>[self addInfinitTimerToCurrentRunloopWithTarget:self selector:@selector(timerRun:) inMode:NSRunLoopCommonModes];
</span></code></pre></td></tr></table></div></figure>


<p>让 timer 所运行的 Runloop mode 和UI 滚动事件的 Runloop mode 一致即可。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[通过 Clang 分析 Block 的机制]]></title>
    <link href="http://ios.dehengxu.com/blog/tong-guo-clang-fen-xi-block-de-ji-zhi/"/>
    <updated>2015-08-23T08:35:18+08:00</updated>
    <id>http://ios.dehengxu.com/blog/tong-guo-clang-fen-xi-block-de-ji-zhi</id>
    <content type="html"><![CDATA[<h3>简单看一下编译器对 __block 做了什么</h3>

<h4>1. 普通变量在栈空间上</h4>

<p>objc:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)useBlock
</span><span class='line'>{
</span><span class='line'>  int  = 2;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>c++:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static void _I_Block4Clang_useBlock(Block4Clang * self, SEL _cmd) {
</span><span class='line'>    int i = 2;
</span><span class='line'>
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<blockquote><p>很简单的处理——没有任何处理，变量依然分配在了栈空间上。</p></blockquote>

<h4>2. __block 修饰的变量</h4>

<p>objc:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)useBlock
</span><span class='line'>{
</span><span class='line'>  int __block i = 2;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>c++:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>struct __Block_byref_i_0 {
</span><span class='line'>  void *__isa;
</span><span class='line'>__Block_byref_i_0 *__forwarding;
</span><span class='line'> int __flags;
</span><span class='line'> int __size;
</span><span class='line'> int i;
</span><span class='line'>};
</span><span class='line'>
</span><span class='line'>static void _I_Block4Clang_useBlock(Block4Clang * self, SEL _cmd) {
</span><span class='line'>    __attribute__((__blocks__(byref))) __Block_byref_i_0 i = {(void*)0,(__Block_byref_i_0 *)&i, 0, sizeof(__Block_byref_i_0), 2};
</span><span class='line'>
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<p>我们看到如果是 block 修饰的变量，虽然定义在在栈空间上，但是编译器会将它分配到堆的空间上(编译器的做法是，通过 <code>__Block_byref_i_0</code> 结构来封装变量 <code>i</code>)，这样的好处是 block 可以通过 <code>__Block_byref_i_0 *</code> 指针访问堆上的变量 i 了。</p>

<h3>再看一下编译器对 block 做了什么</h3>

<h4>1. 空 block。</h4>

<p>objc:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)useBlock
</span><span class='line'>{
</span><span class='line'>  ^(){};
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>c++:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//这是 block 的c++定义
</span><span class='line'>struct __Block4Clang__useBlock_block_impl_0 {
</span><span class='line'>  //这是 block 实现的结构体类型
</span><span class='line'>  struct __block_impl impl;
</span><span class='line'>  //这是 block 描述信息的结构体类型
</span><span class='line'>  struct __Block4Clang__useBlock_block_desc_0* Desc;
</span><span class='line'>
</span><span class='line'>  //这是构造函数
</span><span class='line'>  __Block4Clang__useBlock_block_impl_0(void *fp, struct __Block4Clang__useBlock_block_desc_0 *desc, int flags=0) {
</span><span class='line'>      //指明了 block 类型(分配在栈上的block)
</span><span class='line'>    impl.isa = &_NSConcreteStackBlock;
</span><span class='line'>    impl.Flags = flags;
</span><span class='line'>    //对应的函数指针，这才是实际执行的代码
</span><span class='line'>    impl.FuncPtr = fp;
</span><span class='line'>    //block描述体，包含了数据信息
</span><span class='line'>    Desc = desc;
</span><span class='line'>  }
</span><span class='line'>};
</span><span class='line'>
</span><span class='line'>/**
</span><span class='line'> * block 被转成的 c++ 函数定义
</span><span class='line'> * struct __Block4Clang__useBlock_block_impl_0 *__cself 指向 block 对象本身
</span><span class='line'> */
</span><span class='line'>static void __Block4Clang__useBlock_block_func_0(struct __Block4Clang__useBlock_block_impl_0 *__cself) {
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>    }
</span><span class='line'>//block 描述信息的结构申明
</span><span class='line'>static struct __Block4Clang__useBlock_block_desc_0 {
</span><span class='line'>  size_t reserved;
</span><span class='line'>  size_t Block_size;
</span><span class='line'>} __Block4Clang__useBlock_block_desc_0_DATA = { 0, sizeof(struct __Block4Clang__useBlock_block_impl_0)};
</span><span class='line'>
</span><span class='line'>//实际调用 block 的函数
</span><span class='line'>static void _I_Block4Clang_useBlock(Block4Clang * self, SEL _cmd) {
</span><span class='line'>
</span><span class='line'>    ((void (*)())&__Block4Clang__useBlock_block_impl_0((void *)__Block4Clang__useBlock_block_func_0, &__Block4Clang__useBlock_block_desc_0_DATA));
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h4>2.引用栈变量并修改它</h4>

<p>objc:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)useBlock
</span><span class='line'>{
</span><span class='line'>    __block int i = 2;
</span><span class='line'>    ^(){
</span><span class='line'>        i = 8;
</span><span class='line'>    };
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>c++:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct __Block_byref_i_0 {
</span><span class='line'>  void *__isa;
</span><span class='line'>__Block_byref_i_0 *__forwarding;
</span><span class='line'> int __flags;
</span><span class='line'> int __size;
</span><span class='line'> int i;
</span><span class='line'>};
</span><span class='line'>
</span><span class='line'>struct __Block4Clang__useBlock_block_impl_0 {
</span><span class='line'>  struct __block_impl impl;
</span><span class='line'>  struct __Block4Clang__useBlock_block_desc_0* Desc;
</span><span class='line'>
</span><span class='line'>  //i 变量被封装到了 __Block_byref_i_0 结构内部
</span><span class='line'>  __Block_byref_i_0 *i; // by ref
</span><span class='line'>  __Block4Clang__useBlock_block_impl_0(void *fp, struct __Block4Clang__useBlock_block_desc_0 *desc, __Block_byref_i_0 *_i, int flags=0) : i(_i-&gt;__forwarding) {
</span><span class='line'>    impl.isa = &_NSConcreteStackBlock;
</span><span class='line'>    impl.Flags = flags;
</span><span class='line'>    impl.FuncPtr = fp;
</span><span class='line'>    Desc = desc;
</span><span class='line'>  }
</span><span class='line'>};
</span><span class='line'>static void __Block4Clang__useBlock_block_func_0(struct __Block4Clang__useBlock_block_impl_0 *__cself) {
</span><span class='line'>  __Block_byref_i_0 *i = __cself-&gt;i; // bound by ref
</span><span class='line'>          //访问堆上的变量i，达到 block 可以修改被引用的变量的目的。
</span><span class='line'>        (i-&gt;__forwarding-&gt;i) = 8;
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>/*这里增加了一个 copy 函数，和 dispose 函数，分别用来复制 block 到堆中，释放堆上的 block 对象。*/
</span><span class='line'>
</span><span class='line'>//通过  _Block_object_assign 将src-&gt;i 内容复制到 dst-&gt;i（我们可以推测，src 就是栈上的空间，dst就是堆上的空间，只有这样才能解释当 useBlock 的生命周期结束后，为什么 block 依然还能够执行）
</span><span class='line'>static void __Block4Clang__useBlock_block_copy_0(struct __Block4Clang__useBlock_block_impl_0*dst, struct __Block4Clang__useBlock_block_impl_0*src) {_Block_object_assign((void*)&dst-&gt;i, (void*)src-&gt;i, 8/*BLOCK_FIELD_IS_BYREF*/);}
</span><span class='line'>//dispose 工具函数通过 _Block_object_dispose 来释放 src-&gt;i
</span><span class='line'>static void __Block4Clang__useBlock_block_dispose_0(struct __Block4Clang__useBlock_block_impl_0*src) {_Block_object_dispose((void*)src-&gt;i, 8/*BLOCK_FIELD_IS_BYREF*/);}
</span><span class='line'>
</span><span class='line'>static struct __Block4Clang__useBlock_block_desc_0 {
</span><span class='line'>  size_t reserved;
</span><span class='line'>  size_t Block_size;
</span><span class='line'>  void (*copy)(struct __Block4Clang__useBlock_block_impl_0*, struct __Block4Clang__useBlock_block_impl_0*);
</span><span class='line'>  void (*dispose)(struct __Block4Clang__useBlock_block_impl_0*);
</span><span class='line'>} __Block4Clang__useBlock_block_desc_0_DATA = { 0, sizeof(struct __Block4Clang__useBlock_block_impl_0), __Block4Clang__useBlock_block_copy_0, __Block4Clang__useBlock_block_dispose_0};
</span><span class='line'>
</span><span class='line'>//编译器将 useBlock 方法，转换成了 c++ 函数，和runtime的风格一样
</span><span class='line'>static void _I_Block4Clang_useBlock(Block4Clang * self, SEL _cmd) {
</span><span class='line'>  //在这里将 i 封装到了 __Block_byref_i_0 结构中
</span><span class='line'>    __attribute__((__blocks__(byref))) __Block_byref_i_0 i = {(void*)0,(__Block_byref_i_0 *)&i, 0, sizeof(__Block_byref_i_0), 2};
</span><span class='line'>    //这里才最终执行了 block 调用过程，并将函数指针(__Block4Clang__useBlock_block_func_0)，数据描述指针(&__Block4Clang__useBlock_block_desc_0_DATA)，数据封装(&i，这里的 i 是 __Block_byref_i_0 对象地址)
</span><span class='line'>    ((void (*)())&__Block4Clang__useBlock_block_impl_0((void *)__Block4Clang__useBlock_block_func_0, &__Block4Clang__useBlock_block_desc_0_DATA, (__Block_byref_i_0 *)&i, 570425344));
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h4>3.引用栈变量，但不修改它</h4>

<p>objc:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)useBlock
</span><span class='line'>{
</span><span class='line'>    int i = 2;
</span><span class='line'>    ^(){
</span><span class='line'>        int j = i;
</span><span class='line'>        j++;
</span><span class='line'>        printf("i = %d, j = %d\n", i, j);
</span><span class='line'>    }();
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>c++:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct __Block4Clang__useBlock_block_impl_0 {
</span><span class='line'>  struct __block_impl impl;
</span><span class='line'>  struct __Block4Clang__useBlock_block_desc_0* Desc;
</span><span class='line'>  int i;
</span><span class='line'>  __Block4Clang__useBlock_block_impl_0(void *fp, struct __Block4Clang__useBlock_block_desc_0 *desc, int _i, int flags=0) : i(_i) {
</span><span class='line'>    impl.isa = &_NSConcreteStackBlock;
</span><span class='line'>    impl.Flags = flags;
</span><span class='line'>    impl.FuncPtr = fp;
</span><span class='line'>    Desc = desc;
</span><span class='line'>  }
</span><span class='line'>};
</span><span class='line'>static void __Block4Clang__useBlock_block_func_0(struct __Block4Clang__useBlock_block_impl_0 *__cself) {
</span><span class='line'>  int i = __cself-&gt;i; // bound by copy
</span><span class='line'>
</span><span class='line'>        int j = i;
</span><span class='line'>        j++;
</span><span class='line'>        printf("i = %d, j = %d\n", i, j);
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>static struct __Block4Clang__useBlock_block_desc_0 {
</span><span class='line'>  size_t reserved;
</span><span class='line'>  size_t Block_size;
</span><span class='line'>} __Block4Clang__useBlock_block_desc_0_DATA = { 0, sizeof(struct __Block4Clang__useBlock_block_impl_0)};
</span><span class='line'>
</span><span class='line'>static void _I_Block4Clang_useBlock(Block4Clang * self, SEL _cmd) {
</span><span class='line'>    int i = 2;
</span><span class='line'>    ((void (*)())&__Block4Clang__useBlock_block_impl_0((void *)__Block4Clang__useBlock_block_func_0, &__Block4Clang__useBlock_block_desc_0_DATA, i))();
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[管理自由桥接(Toll-Free Bridging)]]></title>
    <link href="http://ios.dehengxu.com/blog/guan-li-zi-you-qiao-jie-toll-free-bridging/"/>
    <updated>2015-08-22T18:21:12+08:00</updated>
    <id>http://ios.dehengxu.com/blog/guan-li-zi-you-qiao-jie-toll-free-bridging</id>
    <content type="html"><![CDATA[<p>在很多 Cocoa 应用程序中，你需要使用 Core Foundation 风格的对象，有的来自 Core Foundation 框架自己(像：<a href="https://developer.apple.com/library/ios/documentation/CoreFoundation/Reference/CFArrayRef/index.html#//apple_ref/c/tdef/CFArrayRef">CFArrayRef</a> 或 <a href="https://developer.apple.com/library/ios/documentation/CoreFoundation/Reference/CFMutableDictionaryRef/index.html#//apple_ref/c/tdef/CFMutableDictionaryRef">CFMutaleDictionaryRef</a>) 或者来自于适配了 Core Foudation 大会例如 Core Graphics (你可能使用这些类型：<a href="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Reference/CGColorSpace/index.html#//apple_ref/c/tdef/CGColorSpaceRef">CGColorSpaceRef</a> 和  <a href="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Reference/CGGradient/index.html#//apple_ref/c/tdef/CGGradientRef">CGGradientRef</a>)。</p>

<p>编译器不会自动管理 Core Foundation 对象的生命期；你必须调用 <a href="https://developer.apple.com/library/ios/documentation/CoreFoundation/Reference/CFTypeRef/index.html#//apple_ref/c/func/CFRetain">CFRetain</a> 和 <a href="https://developer.apple.com/library/ios/documentation/CoreFoundation/Reference/CFTypeRef/index.html#//apple_ref/c/func/CFRelease">CFRelease</a> (或者响应类型指定的变体) 就像 Core Foundation 内存管理规则中描述的(见 <a href="https://developer.apple.com/library/ios/documentation/CoreFoundation/Conceptual/CFMemoryMgmt/CFMemoryMgmt.html#//apple_ref/doc/uid/10000127i">Memory Management Programming</a>)。</p>

<p>如果你在 Objective-C 和 Core Foundation 风格对象之间互相转换，你需要告诉编译器使用转换(定义在 objc/runtime.h中)或者 Core Foundation 风格的宏(定义在 NSObjecti.h中) 对象所拥有的的语义关系:</p>

<ul>
<li><p>__bridge 在 Objective-C 和 Core Foundation 之间转换指针，而不需要传递所有权。</p></li>
<li><p>__bridge_retained 或 CFBridgingRetain 转换 Objective-C 指针为 Core Foundation 指针，并且传递对象所有权给你，你负责进行 CFRelease 调用，或者调用相关的函数释放对象所有权。</p></li>
<li><p>__bridge_transfer 或 CFBridgingRelease 移动非 Objective-C 指针到 Objective-C ，同时传递所有权到 ARC。 ARC 负责释放对象的所有权。</p></li>
</ul>


<p>举个例子，如果你曾经这样写过代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)logFirstNameOfPerson:(ABRecordRef)person {
</span><span class='line'> 
</span><span class='line'>    NSString *name = (NSString *)ABRecordCopyValue(person, kABPersonFirstNameProperty);
</span><span class='line'>    NSLog(@"Person's first name: %@", name);
</span><span class='line'>    [name release];
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>你可以替换成：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)logFirstNameOfPerson:(ABRecordRef)person {
</span><span class='line'> 
</span><span class='line'>    NSString *name = (NSString *)CFBridgingRelease(ABRecordCopyValue(person, kABPersonFirstNameProperty));
</span><span class='line'>    NSLog(@"Person's first name: %@", name);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h3>编译器处理从 Cocoa 方法中返回的 CF 对象</h3>

<p>编译器根据历史上的 Cocoa 命名规则理解那些返回 Core Foundation 类型的 Objective-C 方法(见: <a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/MemoryMgmt/Articles/MemoryMgmt.html#//apple_ref/doc/uid/10000011i">Advanced Memory Management Programming Guide</a>)。例如，编译器知道,iOS 中 CGColor 通过 <a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIColor_Class/index.html#//apple_ref/occ/cl/UIColor">UIColor</a> 的 <a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIColor_Class/index.html#//apple_ref/occ/instp/UIColor/CGColor">CGColor</a> 方法返回的对象不属于这个规则。你必须使用合适的类型转换，看下面的代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>NSMutableArray *colors = [NSMutableArray arrayWithObject:(id)[[UIColor darkGrayColor] CGColor]];
</span><span class='line'>[colors addObject:(id)[[UIColor lightGrayColor] CGColor]];</span></code></pre></td></tr></table></div></figure>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ARC 内存管理]]></title>
    <link href="http://ios.dehengxu.com/blog/arc-nei-cun-guan-li/"/>
    <updated>2015-08-21T23:06:08+08:00</updated>
    <id>http://ios.dehengxu.com/blog/arc-nei-cun-guan-li</id>
    <content type="html"><![CDATA[<p><a href="https://developer.apple.com/library/ios/releasenotes/ObjectiveC/RN-TransitioningToARC/Introduction/Introduction.html#//apple_ref/doc/uid/TP40011226-CH1-SW13" target="_blank">ARC Overview</a></p>

<p>ARC 概述
 在编译时通过增加额外的代码来确保对象生命周期长度足够所需，但是概念上它通过增加合适的内存管理的代码调用来遵循和 MRC 同样的内存管理原则。</p>

<p>为了让编译器生成正确的代码，ARC 严格限制你能用的方法，以及如何使用自由桥接(toll-free bridging)。ARC 也为对象引用和属性生命增加了新的生命周期修饰符。</p>

<p>ARC 在 Xcode 4.2 OSX v10.6 he v10.7 ， 以及 iOS4， iOS5中提供支持。若引用不被 OSX v10.6 和 iOS4 支持。</p>

<p>对象属性默认情况下是 <code>strong</code> 属性；</p>

<p>ARC 会保证在最后一个对象引用使用前，不会释放掉该对象。</p>

<h3>ARC 的强制新规则</h3>

<p>当使用其他编译器模式的时候，ARC 会暗示一些新的规则。规则会提供一个完全可靠的内存管理模式；在一些情况下，他们简单的强制最好的方式，在一些其他的情况下，规则会简化你的代码，或者你完全不用去处理内存管理。如果你违反了这些规则，你会立刻得到一个编译时错误，而不是一个运行时出现的轻微bug。</p>

<ul>
<li>你不能显示调用 <code>dealloc</code>，或着实现，或者调用 <code>retain</code>, <code>release</code>, <code>retainCount</code> 和 <code>autorelease</code>。</li>
</ul>


<p>同时也不允许使用 @selector(retain), @selector(release) 等等。</p>

<p>你可以实现 <code>dealloc</code> 方法，如果你需要管理一些资源而不是释放一些实例变量。</p>

<p> ARC 中的自定义 <code>dealloc</code> 方法不需要调用 <code>[super dealloc]</code>(它会引起编译错误)。调用 super 的过程会被编译器自动并强制执行。</p>

<p> 你仍然能调用 CFRetain, CFRelease, 和其他相关的 Core Foundation风格对象的函数。</p>

<ul>
<li>你不能使用 <code>NSAllocateObject</code> 或者 <code>NSDeallocateObject</code>。</li>
</ul>


<p>你使用 <code>alloc</code> 创建对象；运行时来负责释放对象；</p>

<ul>
<li>你不能在 C 结构体中使用对象指针。</li>
</ul>


<p>你能创建 <code>Objective-C</code> 对象来管理数据，而不是用 <code>struct</code>。</p>

<ul>
<li>id 和 void * 之间不能进行转换。</li>
</ul>


<p>你必须使用特定的转换方式告诉编译器对象的生命期，你需要这样在 Objective-C 和 Core Foundation 类型之间转换，来做为你传递的函数参数。更多细节，请看 <a href="">Managing Toll-Free Bridging</a></p>

<ul>
<li>你不能使用 <code>NSAutoreleasePool</code> 对象。</li>
</ul>


<p>ARC 提供了 <code>@autoreleasepool</code> 块来代替它。这些比 <code>NSAutoreleasePool</code> 的效率更有优势。</p>

<ul>
<li>你不能使用内存区</li>
</ul>


<p>不再需要使用 <code>NSZone</code>，他们被现代 <code>Objective-C</code> 运行时忽略掉了。</p>

<p>为了和 MRC 代码进行交互，ARC 强制约束方法的命名：</p>

<ul>
<li>你不能给访问器用 new 开头起名。</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//不能正常工作，编译会提示错误。
</span><span class='line'>@property NSString *newName;
</span><span class='line'>
</span><span class='line'>//这样的命名是没问题的。
</span><span class='line'>@property NSString *theNewName;</span></code></pre></td></tr></table></div></figure>


<h3>ARC 带来了新的生命期修饰符</h3>

<p>ARC 为对象带来了一些新的生命期修饰符，还有弱引用。弱引用不会延长对象的生命期，但是会在没有强引用的时候自动设置为 <code>nil</code>。</p>

<p>你可以使用这些修饰符的优势来管理程序中的对象。特殊的是，ARC 不会保护强循环引用。合理的运用弱关系会帮助你避免出现引用循环。</p>

<p>ARC 下，<code>strong</code> 是对象类型属性的默认配置。</p>

<p>下面看一下各种修饰符：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>__strong
</span><span class='line'>__weak
</span><span class='line'>__unsafe_unretained
</span><span class='line'>__autoreleasing</span></code></pre></td></tr></table></div></figure>


<ul>
<li><p><code>__strong</code> 是默认的配置。如果是强指针的时候，对象需要保证生命足够长。</p></li>
<li><p><code>__weak</code> 指定了引用不会保持对象引用。当没有其他的强引用指向它时，弱引用会设置成 <code>nil</code>。</p></li>
<li><p><code>__unsafe_unretained</code> 指定一个引用既不保持对象引用，也不会在不使用时设置为 <code>nil</code>，这容易引野也指针的问题。</p></li>
<li><p><code>__autoreleasing</code> 被用来描述引用类型的参数在方法 return 之后会自动被释放。</p></li>
</ul>


<p>你需要正确的修饰变量，当对一个对象申明使用修饰符的时候，正确的格式如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>ClassName * qulifier variableName;</span></code></pre></td></tr></table></div></figure>


<p>例如:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>NSString * __weak name;
</span><span class='line'>NSString * __unsafe__unretained anotherName;</span></code></pre></td></tr></table></div></figure>


<p>你需要小心地在栈上面使用 __weak 变量，参考下面的例子：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>NSString * __weak string = [[NSString alloc] initWithFormat:@"First Name: %@", [self firstName]];
</span><span class='line'>NSLog(@"string: %@", string);</span></code></pre></td></tr></table></div></figure>


<p>这种情况，编译器会给出警告。因为没有其他对字符串的强引用，所以这个弱引用，会立即释放掉。</p>

<p>你也需要小心的在传參引用的时候使用对象。下面的代码工作正常：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>NSError *error;
</span><span class='line'>BOOL OK = [myObject performOperationWithError:&error];
</span><span class='line'>if (!OK) {
</span><span class='line'>    // Report the error.
</span><span class='line'>    // ...</span></code></pre></td></tr></table></div></figure>


<p>无论如何，error 申明是隐式的：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>NSError * __strong e;</span></code></pre></td></tr></table></div></figure>


<p>方法申明通常会是：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>-(BOOL)performOperationWithError:(NSError * __autoreleasing *)error;</span></code></pre></td></tr></table></div></figure>


<p>编译器会重写代码为：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>NSError * __strong error;
</span><span class='line'>NSError * __autoreleasing tmp = error;
</span><span class='line'>BOOL OK = [myObject performOperationWithError:&tmp];
</span><span class='line'>error = tmp;
</span><span class='line'>if (!OK) {
</span><span class='line'>    // Report the error.
</span><span class='line'>    // ...</span></code></pre></td></tr></table></div></figure>


<p>使用生命期修饰符避免强引用循环</p>

<p>你可以使用生命期修饰符避免强引用循环。举个例子，通常如果你在父子结构中有一个对象图谱，并且所有的父节点需要引用他们的子节点，反之也是这样。你将会制造出父子强引用关系和子父强引用关系。其他的情况可能更微妙，特别当他们用到了 <code>block</code> 对象。</p>

<p>在 MRC 模式下，<code>__block id x;</code> 不会持有(retain) x 的引用。在 ARC 模式，<code>__block id x;</code> 默认会持有 x 的引用。为了在 ARC 下面达到 MRC 的行为，你可以使用 <code>__unsafe_unretained __block id x;</code>。无论如何 <code>__unsafe_unretained</code> 表示未被持有的对象还是比较危险的，所以不鼓励这么使用。可以使用 <strong>weak 或者设置 </strong>block value 为 nil 来接触循环引用。</p>

<p>下面的代码通过 MRC 模式下的方式解释了这种问题。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>MyViewController *myController = [[MyViewController alloc] init…];
</span><span class='line'>// ...
</span><span class='line'>myController.completionHandler =  ^(NSInteger result) {
</span><span class='line'>   [myController dismissViewControllerAnimated:YES completion:nil];
</span><span class='line'>};
</span><span class='line'>[self presentViewController:myController animated:YES completion:^{
</span><span class='line'>   [myController release];
</span><span class='line'>}];</span></code></pre></td></tr></table></div></figure>


<p>你可以使用 <code>__block</code> 修饰符，并在 completion handler 中设置 <code>myController</code> 变量为 nil。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>MyViewController * __block myController = [[MyViewController alloc] init…];
</span><span class='line'>// ...
</span><span class='line'>myController.completionHandler =  ^(NSInteger result) {
</span><span class='line'>    [myController dismissViewControllerAnimated:YES completion:nil];
</span><span class='line'>    myController = nil;
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<p>你也可以使用临时 <code>__weak</code> 变量。下面的代码展示了简单的实现：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>MyViewController *myController = [[MyViewController alloc] init…];
</span><span class='line'>// ...
</span><span class='line'>MyViewController * __weak weakMyViewController = myController;
</span><span class='line'>myController.completionHandler =  ^(NSInteger result) {
</span><span class='line'>    [weakMyViewController dismissViewControllerAnimated:YES completion:nil];
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<p>为了避免引用循环，你需要这样做：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>MyViewController *myController = [[MyViewController alloc] init…];
</span><span class='line'>// ...
</span><span class='line'>MyViewController * __weak weakMyController = myController;
</span><span class='line'>myController.completionHandler =  ^(NSInteger result) {
</span><span class='line'>    MyViewController *strongMyController = weakMyController;
</span><span class='line'>    if (strongMyController) {
</span><span class='line'>        // ...
</span><span class='line'>        [strongMyController dismissViewControllerAnimated:YES completion:nil];
</span><span class='line'>        // ...
</span><span class='line'>    }
</span><span class='line'>    else {
</span><span class='line'>        // Probably nothing...
</span><span class='line'>    }
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<h3>ARC 使用新的表达式来管理自动释放池</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@autoreleasepool {
</span><span class='line'>  // Code, such as a loop that creates a large number of temporary objects.
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>在块开始的时候，释放池被推入栈；块退出(break, return, goto 等等) 释放池会弹出栈。为了兼容现有代码，如果推出会产生异常，那么这个自动释放池不会被弹出。</p>

<h3>管理 Outlets 的方式成为了跨平台方式</h3>

<p>这种申明 <code>outlets</code> 的模式在 iOS 和 OSX 中通过 ARC 得到了改变，并同时跨越了这两个平台。这种模式中，你需要这样来适配：outlets 需要设置为 weak，因为 File&rsquo;s Owner 对于 nib 文件中的顶级对象是强引用。</p>

<p>全部细节请看这里 <a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/LoadingResources/Introduction/Introduction.html#//apple_ref/doc/uid/10000051i" target="_blank">Resource Programming Guide</a> 中的 <a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/LoadingResources/Introduction/Introduction.html#//apple_ref/doc/uid/10000051i" target="_blank">Nib Files</a></p>

<h3>栈变量会被初始化成 nil</h3>

<p>使用 ARC , strong, weak, 和 autoreleasing 栈变量，现在会隐式初始化成 nil。例如:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)myMethod {
</span><span class='line'>    NSString *name;
</span><span class='line'>    NSLog(@"name: %@", name);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h3>使用编译器标志来开启或关闭 ARC</h3>

<p>你可以使用 <code>-fobjc-arc</code> 编译器标志来开启 ARC。如果读你来说某些文件使用 MRC 更方便的话，你也可以对每个文件单独使用 ARC 模式。项目使用 ARC 为默认方式，你可以使用 <code>-fno-objc-arc</code> 来关闭 ARC 。</p>

<p>ARC 被 Xcode 4.2 ， OSX v10.6 和 iOS4 以及后续版本支持。
弱引用不被 OSX v10.6 和 iOS4 支持。
Xcode 4.1 和以前的版本不支持 ARC。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[进程间通信方式]]></title>
    <link href="http://ios.dehengxu.com/blog/jin-cheng-jian-tong-xin-fang-shi/"/>
    <updated>2015-08-21T15:23:01+08:00</updated>
    <id>http://ios.dehengxu.com/blog/jin-cheng-jian-tong-xin-fang-shi</id>
    <content type="html"><![CDATA[<h3>序</h3>

<p>linux下的进程通信手段基本上是从Unix平台上的进程通信手段继承而来的。而对Unix发展做出重大贡献的两大主力AT&amp;T的贝尔实验室及BSD（加州大学伯克利分校的伯克利软件发布中心）在进程间通信方面的侧重点有所不同。前者对Unix早期的进程间通信手段进行了系统的改进和扩充，形成了“system V IPC”，通信进程局限在单个计算机内；后者则跳过了该限制，形成了基于套接口（socket）的进程间通信机制。Linux则把两者继承了下来，如图示：</p>

<p>其中，最初Unix IPC包括：管道、FIFO、信号；System V IPC包括：System V消息队列、System V信号灯、System V共享内存区；Posix IPC包括：   Posix消息队列、Posix信号灯、Posix共享内存区。有两点需要简单说明一下：1）由于Unix版本的多样性，电子电气工程协会（IEEE）开发了一个独立的Unix标准，这个新的ANSI Unix标准被称为计算机环境的可移植性操作系统界面（PSOIX）。现有大部分Unix和流行版本都是遵循POSIX标准的，而Linux从一开始就遵循POSIX标准；2）BSD并不是没有涉足单机内的进程间通信（socket本身就可以用于单机内的进程间通信）。事实上，很多Unix版本的单机IPC留有BSD的痕迹，如4.4BSD支持的匿名内存映射、4.3+BSD对可靠信号语义的实现等等。
图一给出了linux 所支持的各种IPC手段，在本文接下来的讨论中，为了避免概念上的混淆，在尽可能少提及Unix的各个版本的情况下，所有问题的讨论最终都会归结到Linux环境下的进程间通信上来。并且，对于Linux所支持通信手段的不同实现版本（如对于共享内存来说，有Posix共享内存区以及System V共享内存区两个实现版本），将主要介绍Posix API。</p>

<p>linux下进程间通信的几种主要手段简介：</p>

<p>管道（Pipe）及有名管道（named pipe）：管道可用于具有亲缘关系进程间的通信，有名管道克服了管道没有名字的限制，因此，除具有管道所具有的功能外，它还允许无亲缘关系进程间的通信；
信号（Signal）：信号是比较复杂的通信方式，用于通知接受进程有某种事件发生，除了用于进程间通信外，进程还可以发送信号给进程本身；linux除了支持Unix早期信号语义函数sigal外，还支持语义符合Posix.1标准的信号函数sigaction（实际上，该函数是基于BSD的，BSD为了实现可靠信号机制，又能够统一对外接口，用sigaction函数重新实现了signal函数）；</p>

<p>报文（Message）队列（消息队列）：消息队列是消息的链接表，包括Posix消息队列system V消息队列。有足够权限的进程可以向队列中添加消息，被赋予读权限的进程则可以读走队列中的消息。消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺点。
共享内存：使得多个进程可以访问同一块内存空间，是最快的可用IPC形式。是针对其他通信机制运行效率较低而设计的。往往与其它通信机制，如信号量结合使用，来达到进程间的同步及互斥。</p>

<p>信号量（semaphore）：主要作为进程间以及同一进程不同线程之间的同步手段。</p>

<p>套接口（Socket）：更为一般的进程间通信机制，可用于不同机器之间的进程间通信。起初是由Unix系统的BSD分支开发出来的，但现在一般可以移植到其它类Unix系统上：Linux和System V的变种都支持套接字。
下面将对上述通信机制做具体阐述。</p>

<p>附1：参考文献[2]中对linux环境下的进程进行了概括说明：
一般来说，linux下的进程包含以下几个关键要素：
有一段可执行程序；
有专用的系统堆栈空间；
内核中有它的控制块（进程控制块），描述进程所占用的资源，这样，进程才能接受内核的调度；
具有独立的存储空间
进程和线程有时候并不完全区分，而往往根据上下文理解其含义。</p>

<p><a href="http://www.ibm.com/developerworks/cn/linux/l-ipc/" target="_blank">IBM 参考</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Git常见用法]]></title>
    <link href="http://ios.dehengxu.com/blog/gitchang-jian-yong-fa/"/>
    <updated>2015-08-21T13:52:39+08:00</updated>
    <id>http://ios.dehengxu.com/blog/gitchang-jian-yong-fa</id>
    <content type="html"><![CDATA[<h3>1.checkout</h3>

<h4>切换到指定 commit</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>checkout sha-1</span></code></pre></td></tr></table></div></figure>


<h4>切换到分支</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>checkout branch_name</span></code></pre></td></tr></table></div></figure>


<hr />

<h3>2.merge</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>   D--------E
</span><span class='line'>  /
</span><span class='line'> /
</span><span class='line'>A---B---C---F----G master</span></code></pre></td></tr></table></div></figure>




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git merge test</span></code></pre></td></tr></table></div></figure>


<p>合并结果：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>   D-------------E
</span><span class='line'>  /               \
</span><span class='line'> /                 \
</span><span class='line'>A---B---C---F----G test, master</span></code></pre></td></tr></table></div></figure>


<hr />

<h3>3.rebase</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>   D--------E
</span><span class='line'>  /
</span><span class='line'> /
</span><span class='line'>A---B---C---F----G master</span></code></pre></td></tr></table></div></figure>




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git rebase dev</span></code></pre></td></tr></table></div></figure>




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>A---B---D---C---E---F----G  test, master</span></code></pre></td></tr></table></div></figure>


<p>复位基线，将两个分支的提交纪录，合并到一条基线路线上。功能作用上和 merge 类似，但是不会产生新的提交节点，而且不存在多个提交路线。</p>

<p>当出现冲突的时候，先去解决冲突，完成后，使用 <code>rebase --continue</code> 继续 <code>rebase</code> 操作。如果冲突不重要也可以 <code>rebase --skip</code> 忽略冲突。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[NSMutableCopying and NSCopying]]></title>
    <link href="http://ios.dehengxu.com/blog/nsmutablecopying-and-nscopying/"/>
    <updated>2015-08-19T23:24:42+08:00</updated>
    <id>http://ios.dehengxu.com/blog/nsmutablecopying-and-nscopying</id>
    <content type="html"><![CDATA[
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Jekyll Site Class Available Attr]]></title>
    <link href="http://ios.dehengxu.com/blog/jekyll-site-class-available-attr/"/>
    <updated>2015-08-19T11:35:34+08:00</updated>
    <id>http://ios.dehengxu.com/blog/jekyll-site-class-available-attr</id>
    <content type="html"><![CDATA[<p><a href="https://docs.shopify.com/themes/liquid-documentation/basics" target="_blank">LiquidDocument</a></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  class Site
</span><span class='line'>    attr_reader   :source, :dest, :config
</span><span class='line'>    attr_accessor :layouts, :posts, :pages, :static_files, :drafts,
</span><span class='line'>                  :exclude, :include, :lsi, :highlighter, :permalink_style,
</span><span class='line'>                  :time, :future, :unpublished, :safe, :plugins, :limit_posts,
</span><span class='line'>                  :show_drafts, :keep_files, :baseurl, :data, :file_read_opts,
</span><span class='line'>                  :gems, :plugin_manager
</span><span class='line'>
</span><span class='line'>    attr_accessor :converters, :generators, :reader
</span><span class='line'>    attr_reader   :regenerator, :liquid_renderer
</span><span class='line'>
</span><span class='line'>  ...</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Jekyll Configuration Fileds]]></title>
    <link href="http://ios.dehengxu.com/blog/jekyll-configuration-fileds/"/>
    <updated>2015-08-19T11:32:06+08:00</updated>
    <id>http://ios.dehengxu.com/blog/jekyll-configuration-fileds</id>
    <content type="html"><![CDATA[<p>This is Jekyll configuration source file:</p>

<p>For configurating _config.yml use.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># Default options. Overridden by values in _config.yml.
</span><span class='line'># Strings rather than symbols are used for compatibility with YAML.
</span><span class='line'>DEFAULTS = {
</span><span class='line'>  # Where things are
</span><span class='line'>  'source'        =&gt; Dir.pwd,
</span><span class='line'>  'destination'   =&gt; File.join(Dir.pwd, '_site'),
</span><span class='line'>  'plugins'       =&gt; '_plugins',
</span><span class='line'>  'layouts'       =&gt; '_layouts',
</span><span class='line'>  'data_source'   =&gt;  '_data',
</span><span class='line'>  'collections'   =&gt; nil,
</span><span class='line'>
</span><span class='line'>  # Handling Reading
</span><span class='line'>  'safe'          =&gt; false,
</span><span class='line'>  'include'       =&gt; ['.htaccess'],
</span><span class='line'>  'exclude'       =&gt; [],
</span><span class='line'>  'keep_files'    =&gt; ['.git','.svn'],
</span><span class='line'>  'encoding'      =&gt; 'utf-8',
</span><span class='line'>  'markdown_ext'  =&gt; 'markdown,mkdown,mkdn,mkd,md',
</span><span class='line'>  'full_rebuild'  =&gt; false,
</span><span class='line'>
</span><span class='line'>  # Filtering Content
</span><span class='line'>  'show_drafts'   =&gt; nil,
</span><span class='line'>  'limit_posts'   =&gt; 0,
</span><span class='line'>  'future'        =&gt; true,           # remove and make true just default
</span><span class='line'>  'unpublished'   =&gt; false,
</span><span class='line'>
</span><span class='line'>  # Plugins
</span><span class='line'>  'whitelist'     =&gt; [],
</span><span class='line'>  'gems'          =&gt; [],
</span><span class='line'>
</span><span class='line'>  # Conversion
</span><span class='line'>  'markdown'      =&gt; 'kramdown',
</span><span class='line'>  'highlighter'   =&gt; 'rouge',
</span><span class='line'>  'lsi'           =&gt; false,
</span><span class='line'>  'excerpt_separator' =&gt; "\n\n",
</span><span class='line'>
</span><span class='line'>  # Serving
</span><span class='line'>  'detach'        =&gt; false,          # default to not detaching the server
</span><span class='line'>  'port'          =&gt; '4000',
</span><span class='line'>  'host'          =&gt; '127.0.0.1',
</span><span class='line'>  'baseurl'       =&gt; '',
</span><span class='line'>
</span><span class='line'>  # Output Configuration
</span><span class='line'>  'permalink'     =&gt; 'date',
</span><span class='line'>  'paginate_path' =&gt; '/page:num',
</span><span class='line'>  'timezone'      =&gt; nil,           # use the local timezone
</span><span class='line'>
</span><span class='line'>  'quiet'         =&gt; false,
</span><span class='line'>  'verbose'       =&gt; false,
</span><span class='line'>  'defaults'      =&gt; [],
</span><span class='line'>
</span><span class='line'>  'rdiscount' =&gt; {
</span><span class='line'>    'extensions' =&gt; []
</span><span class='line'>  },
</span><span class='line'>
</span><span class='line'>  'redcarpet' =&gt; {
</span><span class='line'>    'extensions' =&gt; []
</span><span class='line'>  },
</span><span class='line'>
</span><span class='line'>  'kramdown' =&gt; {
</span><span class='line'>    'auto_ids'       =&gt; true,
</span><span class='line'>    'footnote_nr'    =&gt; 1,
</span><span class='line'>    'entity_output'  =&gt; 'as_char',
</span><span class='line'>    'toc_levels'     =&gt; '1..6',
</span><span class='line'>    'smart_quotes'   =&gt; 'lsquo,rsquo,ldquo,rdquo',
</span><span class='line'>    'enable_coderay' =&gt; false,
</span><span class='line'>
</span><span class='line'>    'coderay' =&gt; {
</span><span class='line'>      'coderay_wrap'              =&gt; 'div',
</span><span class='line'>      'coderay_line_numbers'      =&gt; 'inline',
</span><span class='line'>      'coderay_line_number_start' =&gt; 1,
</span><span class='line'>      'coderay_tab_width'         =&gt; 4,
</span><span class='line'>      'coderay_bold_every'        =&gt; 10,
</span><span class='line'>      'coderay_css'               =&gt; 'style'
</span><span class='line'>    }
</span><span class='line'>  }
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
</feed>
